<!-- CBass — Console SPA Takeover (Squarespace 7.1, single code block) -->
<section id="cb-console-root" aria-label="Console interface">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600;700&display=swap');
    :root{
      --cb-bg:#0f0f0f; --cb-fg:#fff; --cb-dim:#8a8a8a; --cb-accent:#fff;
      --cb-font: 'IBM Plex Mono', 'Courier New', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --cb-pad: 16px; --cb-line: 1.5; --cb-maxw: 1200px;
      --cb-input-h: 40px; --cb-caret-w: 8px; --cb-fs: 15px;
      --cb-border:#1b1b1b;
      --cb-ascii-fs: 8px; /* size of ASCII art only */
    }

    /* Takeover + hide native page scroll */
    html, body { height:100%; }
    body { overflow:hidden !important; background:#0f0f0f; }

    /* Fullscreen console layer */
    #cb-console{
      position: fixed; inset:0; z-index: 999999;
      display:grid; grid-template-rows: 1fr auto;
      background: var(--cb-bg); color: var(--cb-fg);
      font-family: 'IBM Plex Mono', 'Courier New', ui-monospace, Menlo, Consolas, Monaco, 'Apple Braille', 'Segoe UI Symbol', 'Noto Sans Symbols 2', monospace;
    }

    /* Screen (scrollback) */
    #cb-screen{
      position: relative;
      overflow: auto;
      padding: calc(var(--cb-pad) + 4px) var(--cb-pad) var(--cb-pad) var(--cb-pad);
      scrollbar-width: thin;
      outline: none;
    }
    #cb-screen::-webkit-scrollbar{ height:8px; width:8px; }
    #cb-screen::-webkit-scrollbar-thumb{ background:#333; }
    #cb-screen .line { white-space: pre-wrap; word-break: break-word; }
    #cb-screen .line.error{ color:#ff6b6b; }
    /* Better selection (like terminals) */
#cb-screen ::selection{ background:#2a2a2a; color:#fff; }

/* Subtle CRT scanlines + bloom pulse on error */
#cb-console::after{
  content:''; position:fixed; inset:0; pointer-events:none; z-index:2;
  background:
    repeating-linear-gradient(0deg, rgba(255,255,255,.035) 0px, rgba(255,255,255,.035) 1px, transparent 2px, transparent 3px);
  mix-blend-mode: soft-light; opacity:.25;
}
@keyframes cb-flash { 0%{ box-shadow:0 0 0 #fff; } 100%{ box-shadow:0 0 90px rgba(255,255,255,.12) inset; } }
.cb-flash{ animation: cb-flash .12s ease-out; }
    #cb-screen .dim{ color: var(--cb-dim); }
    #cb-screen .accent{ color: var(--cb-accent); }
    #cb-screen .banner{
      white-space: pre; font-weight: 700; margin-bottom: 8px;
    }
    #cb-screen .block{
      border-left: 2px solid var(--cb-border); padding-left: 12px; margin: 6px 0 10px;
    }
    #cb-screen .kbd{
      padding:1px 4px; border:1px solid var(--cb-border); border-radius:3px; font-weight:700;
    }

    /* Prompt row */

    #cb-promptbar{
      display:flex; align-items:center; gap:10px;
      border-top:1px solid var(--cb-border);
      padding: 6px var(--cb-pad);
      min-height: var(--cb-input-h);
    }
    #cb-commands{
  position: fixed;
  left: var(--cb-pad);
  bottom: calc(var(--cb-input-h) + var(--cb-pad) + 6px);
  z-index: 2;
  color: var(--cb-dim);
  white-space: pre-wrap;
  max-width: min(70ch, 90vw);
  pointer-events: none;
  font: inherit;
  display: none; /* shown only on work pages */
}

    #cb-path{ color: var(--cb-dim); }
    #cb-ps1{ color: var(--cb-accent); font-weight:700; }
    #cb-input-wrap{
      position: relative; flex:1; display:flex; align-items:center; gap:6px;
    }
    #cb-input{
  background: transparent; color: transparent;   /* hide native text */
  caret-color: transparent;                      /* hide native caret */
  border: none; outline: none; flex:1;
  font: inherit; letter-spacing: .2px;
}
/* Visible echo of input text (overlays input) */
#cb-ghost{
  position:absolute; left:0; top:50%; transform: translateY(-50%);
  white-space: pre; pointer-events:none; user-select:none;
  font: inherit; letter-spacing:.2px; color: var(--cb-fg);
}

/* Custom caret positioned at end of #cb-ghost */
#cb-caret{
  position:absolute; left:0; top:50%; transform: translateY(-50%);
  width: var(--cb-caret-w); height: 1.2em;
  background: var(--cb-accent); opacity:1;
  animation: blink 1.05s steps(1,end) infinite;
  /* remove any margin/align rules from before */
}

    /* One-line row (no wrapping) with horizontal scroll for overflow */
#cb-screen .line.nowrap{
  white-space: pre;          /* preserve spaces, never wrap */
  overflow-x: auto;          /* allow sideways scroll on small screens */
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  margin-bottom: 6px;        /* breathing room above mobile chips */
}
#cb-screen .line.nowrap::-webkit-scrollbar{ height:6px; }

    @keyframes blink { 50% { opacity: 0; } }

    /* Mobile helper chips (tap to paste) */
    #cb-chips{
      display:flex; gap:8px; padding: 4px var(--cb-pad) 10px;
      border-top:1px dashed var(--cb-border);
      flex-wrap: wrap;
    }
    #cb-chips button{
      background:#0a0a0a; color:#ddd; border:1px solid var(--cb-border);
      padding: 4px 8px; border-radius: 4px; font: inherit; cursor:pointer;
    }
    #cb-chips button:focus-visible{ outline:2px solid var(--cb-accent); outline-offset:2px; }

    /* Make sure Squarespace elements don’t stack above */
    .sqs-announcement-bar, header.Header, .Header, .Site, .sqs-site-container, .Footer { pointer-events:none; }

    /* Color themes (you can switch via command: theme amber|green|white) */
    .cb-theme-amber { --cb-bg:#0f0f0f; --cb-fg:#ffdca8; --cb-dim:#9a845f; --cb-accent:#ffbf58; }
    .cb-theme-green { --cb-bg:#0f0f0f; --cb-fg:#b5f7b5; --cb-dim:#6ea16e; --cb-accent:#6bff6b; }
    .cb-theme-white { --cb-bg:#0f0f0f; --cb-fg:#fff; --cb-dim:#8a8a8a; --cb-accent:#fff; }

    /* Accessibility helpers (visually hidden text for screen readers) */
    .sr-only{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
    /* ASCII image blocks (ensure braille/block glyph support) */
#cb-screen pre.ascii-img{
  margin: 4px 0 10px;
  white-space: pre;
  font-family: 'Courier New', ui-monospace, Menlo, Consolas, Monaco, 'Apple Braille', 'Segoe UI Symbol', 'Noto Sans Symbols 2', monospace;
  line-height: 1;
  font-family: var(--cb-font);
  font-size: var(--cb-ascii-fs);
  letter-spacing: 0;
}
/* Inline completion hint (dim, after typed text) */
#cb-hint{
  position:absolute; left:0; top:50%; transform: translateY(-50%);
  white-space: pre; pointer-events:none; user-select:none;
  font: inherit; letter-spacing:.2px; color: var(--cb-dim); opacity:.7;
}

/* CRT vignette under scanlines */
#cb-console::before{
  content:''; position:fixed; inset:0; pointer-events:none; z-index:1;
  background: radial-gradient(ellipse at center,
              rgba(0,0,0,0) 40%, rgba(0,0,0,.15) 85%, rgba(0,0,0,.32) 100%);
}
/* 1) New design tokens so themes can tweak scanlines, chips, selection */
  :root{
    /* existing vars … */
    --cb-scanline: rgba(255,255,255,.035);
    --cb-chip-bg:#0a0a0a; --cb-chip-fg:#ddd;
    --cb-select-bg:#2a2a2a; --cb-select-fg:#fff;
  }

  /* 2) NEW: black-on-white theme */
  .cb-theme-bw{
    --cb-bg:#fff; --cb-fg:#111; --cb-dim:#666; --cb-accent:#0f0f0f;
    --cb-border:#e5e5e5;
    --cb-scanline: rgba(0,0,0,.06);
    --cb-chip-bg:#f6f6f6; --cb-chip-fg:#222;
    --cb-select-bg:#cfe3ff; --cb-select-fg:#0f0f0f;
  }

  /* 3) Make scanlines/selection/chips use the new variables */
  #cb-console::after{
    background:
      repeating-linear-gradient(
        0deg,
        var(--cb-scanline) 0px,
        var(--cb-scanline) 1px,
        transparent 2px,
        transparent 3px
      );
  }
  #cb-screen ::selection{ background:var(--cb-select-bg); color:var(--cb-select-fg); }
  #cb-chips button{
    background:var(--cb-chip-bg); color:var(--cb-chip-fg);
    border:1px solid var(--cb-border);
  }
  /* — sprite: bottom-right idle buddy — */

@media (prefers-reduced-motion: reduce){
  #cb-sprite{ opacity:.85; }
}
#cb-sprite{
  position: fixed;
  right: var(--cb-pad);
  bottom: calc(var(--cb-input-h) + var(--cb-pad) + 6px);
  z-index: 3;
  color: var(--cb-accent);
  opacity: .92;
  pointer-events: none;
  user-select: none;
  line-height: 1;
  white-space: pre;

  /* ensure tiny ASCII size + fonts that include Braille blocks */
  font-size: var(--cb-ascii-fs);
  font-family:
    'IBM Plex Mono','Courier New',ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,
    'Apple Braille','Segoe UI Symbol','Noto Sans Symbols 2',monospace;
}
/* Mobile-friendly defaults */
:root{ --cb-fs:16px; --cb-input-h:52px; }          /* stop iOS zoom; taller prompt */
#cb-console{ height:100dvh; }                       /* respect browser UI toolbars */

/* Use native caret on touch devices (better selection/dictation) */
.cb-mobile #cb-input{ color:var(--cb-fg); caret-color:var(--cb-accent); }
.cb-mobile #cb-ghost, .cb-mobile #cb-caret, .cb-mobile #cb-hint{ display:none; }

/* Safe areas + keyboard lift (JS sets --kb) */
#cb-promptbar{ padding-bottom: calc(var(--cb-pad) + env(safe-area-inset-bottom,0px));
               margin-bottom: var(--kb, 0px); }
#cb-commands, #cb-sprite{
  bottom: calc(var(--cb-input-h) + var(--cb-pad) + env(safe-area-inset-bottom,0px) + var(--kb,0px));
}

/* No accidental zoom/delay on taps */
#cb-console, #cb-screen, #cb-chips{ touch-action: manipulation; }

/* ASCII art never overflows horizontally */
pre.ascii-img{ max-width:100%; overflow-x:hidden; }

/* Reduced motion: calm scanlines + caret */
@media (prefers-reduced-motion: reduce){
  #cb-console::after{ opacity:.12; }
  #cb-caret{ animation:none; opacity:1; }
}
/* ===== Sprite FX (console v1) ===== */

/* only allow pointer interactions on fine pointers */
@media (any-pointer:fine){ #cb-sprite{ pointer-events:auto; } }
@media (pointer:coarse){ #cb-sprite{ pointer-events:none; } }
#cb-sprite{  transition: text-shadow .18s ease, filter .18s ease, transform .18s ease, box-shadow .18s ease;
}
@media (any-hover:hover){
  #cb-sprite:hover{ text-shadow: 0 0 6px var(--cb-accent); }
}


/* faint console-surface glow directly under the sprite (approved: faint) */
#cb-sprite::before{
  content:''; position:absolute; inset:-8px; border-radius:10px;
  pointer-events:none; opacity:0; transition:opacity .18s ease;
  background: radial-gradient(closest-side, var(--cb-accent) 15%, transparent 70%);
  mix-blend-mode: soft-light;
}
#cb-sprite.is-hover::before{ opacity:.08; }
.cb-theme-bw #cb-sprite::before{ mix-blend-mode:multiply; opacity:.06; }

/* one extra child for effects */
#cb-sprite .fx-cone{
  position:absolute; left:50%; transform:translateX(-50%);
  top: 1.2em; width:min(36ch, 60vw); height:12ch; pointer-events:none;
  opacity:0; filter: blur(.6px); transition: opacity .18s ease;
  background: radial-gradient(ellipse at top, rgba(255,255,255,.14), rgba(255,255,255,0) 70%);
}
.cb-theme-bw #cb-sprite .fx-cone{
  background: radial-gradient(ellipse at top, rgba(0,0,0,.16), rgba(0,0,0,0) 70%);
}
#cb-sprite[data-kind="streetlight"].is-hover .fx-cone{ opacity:.12; }

/* ===== idle animations (low amplitude, low frequency) ===== */

/* NOTE — vibrato */
@keyframes cb-note-vib { 0%,100%{ transform: translateY(0) } 50%{ transform: translateY(-0.5px) } }
#cb-sprite[data-kind="note"]{ animation: cb-note-vib 7.5s ease-in-out infinite; }
#cb-sprite[data-kind="note"].is-hover{ text-shadow: 0 0 8px var(--cb-accent), 1px 0 0 var(--cb-dim); }

/* STREETLIGHT — sodium hum */
@keyframes cb-sodium-hum { 0%,100%{ filter: brightness(1) } 50%{ filter: brightness(1.04) } }
#cb-sprite[data-kind="streetlight"]{ animation: cb-sodium-hum 16s ease-in-out infinite; }

/* CURSOR — blink */
@keyframes cb-caret-blink { 0%,45%{ opacity:1 } 55%,100%{ opacity:.1 } }
#cb-sprite[data-kind="cursor"]{ animation: cb-caret-blink 1.05s steps(1,end) infinite; }

/* Reduced motion = no transforms, only mild brightness/opacity */
@media (prefers-reduced-motion: reduce){
  #cb-sprite{ animation:none !important; transform:none !important; }
}

/* ===== interaction states ===== */
#cb-sprite.is-hover{ text-shadow: 0 0 6px var(--cb-accent); }
#cb-sprite.is-active{ transform: scale(.98); filter: brightness(1.08); }
#cb-sprite[data-kind="cursor"].is-hover{ box-shadow: inset 0 -1px 0 0 var(--cb-accent); }
#cb-sprite[data-kind="cursor"].is-active{ text-shadow: 0 0 10px var(--cb-accent); }
#cb-sprite[data-kind="cursor"].is-typing{ filter: brightness(1.15); }

/* Note: long-hover echo-tail (tiny ascending trail) */
#cb-sprite[data-kind="note"].is-longhover{
  text-shadow:
    0 0 8px var(--cb-accent),
    1px -1px 0 rgba(255,255,255,.10),
    2px -2px 0 rgba(255,255,255,.065);
}

/* Streetlight: rare micro-flicker on demand */
@keyframes cb-bulb-flicker {
  0%,100%{ opacity:1 } 20%{ opacity:.6 } 40%{ opacity:.9 } 60%{ opacity:.5 } 80%{ opacity:1 }
}
#cb-sprite[data-kind="streetlight"].do-flicker{
  animation: cb-bulb-flicker .14s linear 1, cb-sodium-hum 16s ease-in-out infinite;
}

  </style>

  <div id="cb-console" class="cb-theme-white" role="application" aria-roledescription="Terminal style interface">
    <div id="cb-screen" role="log" aria-live="polite" aria-atomic="false" tabindex="0"></div>

    <div id="cb-chips" aria-label="Quick commands for mobile">
      <button data-insert="help">help</button>
      <button data-insert="home">home</button>
      <button data-insert="works">works</button>
<button data-insert="blog">blog</button>
      <button data-insert="sounds">sounds</button>
      <button data-insert="about">about</button>
      <button data-insert="press">press</button>
      <button data-insert="contact">contact</button>
      <button data-insert="clear">clear</button>
    </div>
    <pre id="cb-commands" aria-hidden="true"></pre>

    <div id="cb-promptbar" aria-label="Command prompt">
      <span id="cb-path">/cbassuarez</span>
      <span id="cb-ps1">$</span>
      <div id="cb-input-wrap">
        <label class="sr-only" for="cb-input">Type a command and press Enter</label>
<span id="cb-ghost" aria-hidden="true"></span>
<span id="cb-hint"  aria-hidden="true"></span>
<input id="cb-input" autocomplete="off" spellcheck="false" aria-label="Console command input" />
<i id="cb-caret" aria-hidden="true"></i>

      </div>
    </div>
  </div>

  <script>
(() => {
  // Ensure viewport is locked (Squarespace code block-safe)
  const sel = 'meta[name="viewport"]';
  const content = 'width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no';
  let m = document.querySelector(sel);
  if (!m) { m = document.createElement('meta'); m.name = 'viewport'; document.head.appendChild(m); }
  m.setAttribute('content', content);
})();
</script>
  <script>
if (window.__CB_CONSOLE_BOOTED__) { throw new Error('cb-console: duplicate script blocked'); }
window.__CB_CONSOLE_BOOTED__ = true;


  (() => {
    /* ----------------------------
       CONTENT STORE (v1 placeholders)
       Replace summaries/notes with real content; add/remove works freely.
    ----------------------------- */

    const DATA = {
      meta:{
        site:'/cbassuarez', email:'contact@cbassuarez.com', socials:[
          {name:'Instagram', url:'https://instagram.com/cbassuarez'},
          {name:'YouTube', url:'https://youtube.com/@cbassuarez'},
        ], 
        form:{ 
      endpoint: 'https://formspree.io/f/mjkepaeo', // <- put your endpoint here
      method: 'json' // 'json' (application/json) or 'form' (x-www-form-urlencoded)
    },
    // NEW
  presskit:'under construction',   // change if different
  cv:'',                                     // add link when ready
  now:[
    'rings/resonators mix',
    '25HUNDRED',
    'thesis edits',
    'SyncTimer beta v0.7'
  ],
  portrait:'https://drive.google.com/file/d/1Tng04R2BInw5u7hm54m384M7_wGQAmeL/view?usp=sharing'
},
      
      about: `Composer-performer + visual artist. Console v1 of cbassuarez.com.
This site is an interactive terminal. Type 'help' to get started.`,
      press: `cbassuarez - press
under construction`,
      contact: `Email: contact@cbassuarez.com
Links: dexdsl.org; synctimerapp.com
Studio: Los Angeles, CA`,
      works:[
        {id:1, slug:'ringsresonators', title:'Rings/Resonators', year:2025, type:'album', tags:['album'],
         summary:`An album of prepared-piano resonances, captured through body amplification and spatial recording. Building on Amplifications, this release pushes the approach further into density and scale. Vibraphone and multip-percussion played through a ring of pianos.`,
         pic:'https://drive.google.com/file/d/1seBBe0l0Ra-IEoZfQs6eEhpVPP28535p/',
         details:[ `The piano is taken here as a resonant chassis: wood, strings, plate, and air coupled together into one surface. Objects and mutes shape its vocabulary, while contact capture and amplification extend its body outward into the room. What you hear is less a keyboard performance than a field of resonances—sudden excitations, sympathetic vibrations, and sustained blooms that fill and bend the space.`, `This album continues the line set out in Amplifications, but with greater intensity. The sound field is closer and more forceful, emphasizing saturation as much as detail. Spatial mixing renders a front stage that stays intelligible, with energy spreading to the sides and rear as the instrument’s frame answers back.`, `The result is a spatial document: a listener’s position inside the piano’s acoustic field. Dynamic extremes and tonal shifts emerge from this perspective, giving scale to both the smallest preparation and the largest resonance.` ],
         credits:[ `Sebastian Suarez-Solis, mix, audio recording`, `Recorded at CalArts, room A300` ],
         press:[  ],
         links:[ `Links TBA` ]},
        {id:2, slug:'25hundred', title:'25HUNDRED', year:2025, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:3, slug:'embodied-space', title:'EMBODIED MANIFESTATIONS of SPACE in ARTWORKS', year:2025, type:'thesis', tags:['thesis', 'research', 'portfolio'],
         summary:`Topic Driven Research portfolio (thesis), California Institute of the Arts; 

1. CONCERNING HUMAN UNDERSTANDING: The Case for a Radical Constructivist Approach in Music and Aesthetic Theory

2. IMMANENT PRACTICE: The Metaontology of Percussion Performance

3. Afro-Venezuelan Music Rituals in Caribbean Venezuela and their diasporic connection to Ewe Music`,
         pic:'https://drive.google.com/file/d/1GUr8-SLZH0oL3zA_Hbw37IPVY4WtMjfL/view?usp=sharing',
         details:[ `Topic Driven Research Summaries`, `Sebastian Suarez-Solis, DMA Composer-Performer, CalArts`, `Topic One:`, `“CONCERNING HUMAN UNDERSTANDING: The Case for a Radical Constructivist Approach in Music and Aesthetic Theory”`, `This topic advances a programmatic inquiry into whether second-order cybernetics (SoC) can yield a rigorously transferable method for artmaking. Framed by Margaret Mead’s framework that “the cybernetics of cybernetics” must include the observer, the study asks how recursion, self-reference, eigenforms, and the Subject might ground an aesthetics that is neither scientific nor purely relativist. This is done through an analytical and practical framework elucidated below.`, `The historical narrative highlights three archetypal “scientific artworks” as milestones in a century-long dialogue between art and feedback. Nicolas Schöffer’s CYSP 1 (1956) formalized cybernetic authorship by welding sensors to a kinetic sculpture, it was the first of its kind as a self-proclaimed cybernetic artwork`, `Eduardo Kac and Ikuo Nakamura’s Essay Concerning Human Understanding (1994) extended Schöffer’s premise into a telematic plant–bird feedback loop`, `and Olafur Eliasson’s long-running exploration of mirrors, monofrequency lamps, and shadow architectures (1997-2025) constitute an eigenform, a self-stabilizing pattern of patterns over several artworks, years, and places. These works collectively realize how second-order cybernetics displaces the Romantic artist-subject with distributed networks of human and non-human actants.`, `I draw from Margaret Mead, Ernst von Glasersfeld, Ranulph Glanville, and Pesi Masani, whose writings describe feedback, equilibrium, and information as fundamentally constructivist phenomena. I utilize concepts of phenomenology, technē, and Deleuzian immanence to argue that modern artworks are instantiated not in objective form but in the recursive coupling of system and observer. Consequently, the central opposition is no longer objectivity versus subjectivity but realist measurement versus radical constructivist insight, which I consider more of a fertile, Fichtian dialectic, rather than something mutually exclusive.`, `In terms of methodology, I reject large-scale empirical testing in favor of case studies and practical exercises that model cybernetic artworks as logical ecosystems of inputs, transformations, and outputs`, `this is explored through a practicum of my own, CONSTRUCTIONS, a cybernetic artwork that premiered at CalArts April 2025. Literature drawn from Masani, Kollias, Mailman, Scholte, Scott, and Shanken bring in complementary taxonomies through which each artwork’s cybernetic status is positioned. This approach is reflexive as such: every analytical move is itself an eigenbehavior, foregrounding the constructivist roles of scholarly agency.`, `My findings reveal both the promise and the paradox of a hard SoC aesthetics: on one hand, Eliasson’s longstanding manipulations of monochromatic light corroborate the formation of a lifelong artistic eigenform, showing how recursive material constraints can incubate a coherent aesthetic signature over decades`, `Kac and Nakamura’s plant-bird duet likewise demonstrates that cybernetic recursion can generate emergent sonic behavior while remaining necessarily sensitive to human proximity, thereby confirming Mead’s insistence on observer participation. However, I argue attempts to impose objective metrics onto such works are epistemically lopsided: Masani’s laboratory-style protocols illuminate feedback topologies but eclipse the lived phenomenology that renders the art affective`, `conversely, radical constructivist readings capture experiential richness at the cost of replicable precision. In any case, the mismatch lies in differentiation between the ante- and ex post facto activities which govern the creative process, with realist cybernetics often on the ex post facto end of creation and traditional artmaking on the ante facto side of the schema.`, `Accordingly, I conclude that the salient question is not “is this work cybernetic?” but “can cybernetics help us make sense of this work, and to what end?”. A provisional answer argues for methodological pluralism in the classroom and the studio: quantitative modeling maximizes informational conversion, while constructivist lenses expose how subjects co-construct artistic reality. The broader implication of my work in this topic is the advancement of a curriculum that privileges technē and phenomenology – ultimately skills of making and sensing – over post-hoc numerical validation, without outrightly rejecting the latter’s diagnostic power. By folding analytic recursion back onto itself (cybernetically), my research not only maps a lineage of cybernetic art but enacts the radical constructivist stance I advocate, modeling scholarship as a self-observing, self-adjusting system poised between empirical rigor and experiential depth.`, `Topic Two:`, `“IMMANENT PRACTICE: The Metaontology of Percussion Performance”`, `My research into the ontologies of percussion performance practice interrogates how twentieth- and twenty-first-century solo percussion emerged from, and continues to be shaped by, the intertwined forces of industrialization, imperial techno-capitalism, and neoliberal individualism. Framed by the guiding question “how do machine aesthetics inform ontologies of percussion?” I propose an immanent-practice model—drawn from Deleuze & Guattari’s plane of consistency—to reveal multiple, co-existing ontological logics at work whenever a percussionist strikes, touches, or otherwise activates sound objects and ultimately, from where those chosen sound objects come.`, `After a cursory mapping of the historical processes by which both solo percussion and machine aesthetics gained popularity in the 20th centrury, I delineate three competing ontological paradigms—action, access, and function—and argue that dialectic “black-and-white” accounts such as the above are inadequate to describe the technopolitical realities of percussion today. By contrast, an immanent model allows distinct ontologies to overlap and re-configure locally, their boundaries mediated by machine aesthetics that pervade both instruments and the broader capitalist lifeworld. Key touchstones include Jones’s “ontology of access,” Beauton’s critique of technocapital immanence, and Koloogani & Ghazvini’s reading of Soviet avant-garde machine art. Visual and haptic phenomenology also play a central role: Curtin’s work on vibration and Zinman’s studies of synthetic film sound aid in elucidating the claim that percussion is always already a hybrid audio-visual event whose gestural visibility reinforces machinic metaphors: riveting, piston-like strokes, assembly-line repetition.`, `Methodologically, the project integrates (1) a critical literature review spanning music theory, media studies, and Marxist cultural critique`, `(2) four performer-centred case studies—Amy Knoles, Steven Schick, Josh Jones, and Bonnie Whiting—examined through semi-structured interviews, archival performance videos, and analysis of written texts`, `and (3) comparative score analysis of seminal solo and multi-percussion works such as Stockhausen’s Zyklus and Xenakis’s Rebonds.`, `My research positions the concept of immanent practice as a unifying yet flexible framework capable of capturing plural ontologies without collapsing them into a single teleology. It complicates prevailing narratives that treat solo percussion’s ascent as purely artistic evolution, revealing instead a mesh of technocultural forces that both enable and demarcate creative agency.`, `Pedagogically, it urges percussion studios to foreground material histories, access politics, and expressive agency in curricula. For scholarship, it seeds future comparative work on non-Western percussion traditions and digitally networked performances, testing whether immanent models can account for globalized, latency-bound ontologies of strike and response`, `this is in the aims of furthering the groundwork already laid out in this field by the Schick studio (Jones, Beauton, et al).`, `Topic Three:`, `Afro-Venezuelan Music Rituals in Caribbean Venezuela and their diasporic connection to Ewe Music`, `I confront the long-standing research vacuum surrounding Afro-Venezuelan ritual music and its West-African roots by raising two intertwined questions: (1) Do coastal Venezuelan festivals preserve musical and ritual structures traceable to Ewe and related West-African traditions? (2) How do these practices actively produce de-colonial social space for Black communities in Venezuela, especially in the regions of Barlovento, Caracas, Chuao, and Yare?`, `The trade in enslaved Africans established maroon settlements (cumbes) in Barlovento and other Caribbean-facing towns`, `there, African cosmologies fused with imposed Catholic observances and indigenous ways of being, giving rise to Corpus Christi’s Diablos Danzantes and the June festivals of San Juan Bautista.  Sources from Aleman-Fernández (1990) and Lengwinat (2017) show how drum-centred rituals, masked processions, and spirit invocations were preserved precisely because they were reframed as church feasts, a phenomenon aggravated by twentieth-century Venezuelan folklorisation policies identified by Núñez (2004) and Walton (2017).`, `The project combines archival analysis, comparative transcription of recorded tambor and mina drumming (e.g., Tambor Urbano, Un Solo Pueblo), analysis of  ethnographic interviews with festival bearers, and two detailed case studies: the Diablos Danzantes (Corpus Christi festival, in May) and the San Juan cycle in Barlovento (late June).  Rhythmic and functional features are measured against Ewe drum-ensemble grid patterns (Gerstin 2017) to distinguish direct retentions from creolised inventions. Rhythmic transcription aids in demonstrating the link between the drum figures of Barlovento and the Ewe bell grid: the Barloventoan mina and curbata’s ostinati, call-and-response chants, and lead-drum exchanges replicate the atsimevu-led structures of Agbadza and Gahu. A cursory explanation of auxiliary practices like Quitiplás keeps the study grounded in contemporary cultural practice.`, `In terms of analysis, Henri Lefebvre’s concept of the social “production of space” illuminates the manner in which public spaces (namely processional routes, church courtyards, and village plazas, in this case) are transformed into experiential “capital-p” places of Afro-descendant self-determination. Complementarily, Antonio Gramsci’s paradigm of the counter-hegemonic “war of position” elucidates how these ceremonial practices persist as state-endorsed yet quietly insurgent interventions within a predominantly Catholic-mestizo hegemony.`, `Recognizing Afro-Venezuelan festivals as part of the broader Black Atlantic and Southern Caribbean confronts Afro-Cuban/AfroCaribbean curricula that privilege Cuba in percussion pedagogy`, `this inclusion enriches rhythm-pedagogy, expands instrumentaria (quitiplás, furruco), and models community-based practices documented by Lengwinat and Walton. Finally, by situating music-making inside spatial theory, my research offers a template for analysing other Latin-American ritual soundscapes and calls for deeper fieldwork once current  travel and political constraints subside.`, `As such, Afro-Venezuelan ritual musics are not peripheral curiosities but dynamic, place-making arts that sustain West-African rhythmic logics, negotiate colonial power, and demand a central place in trans-Atlantic musicology and decolonial pedagogy.` ],
         credits:[ `Topic One:`, {role:'“CONCERNING HUMAN UNDERSTANDING', name:'The Case for a Radical Constructivist Approach in Music and Aesthetic Theory”'}, `SEBASTIAN SUAREZ-SOLIS, DMA COMPOSER-PERFORMER, CALARTS`, `TIM FEENEY, NICHOLAS ENGLAND CHAIR IN MUSIC, CALARTS`, `Topic Two:`, {role:'“IMMANENT PRACTICE', name:'The Metaontology of Percussion Performance”'}, `SEBASTIAN SUAREZ-SOLIS, DMA COMPOSER-PERFORMER, CALARTS`, `VOLKER STRAEBEL, DEAN,  HERB ALPERT SCHOOL of MUSIC, RICHARD SEAVER DISTINGUISHED CHAIR IN MUSIC, CALARTS`, `Topic Three:`, `Afro-Venezuelan Music Rituals in Caribbean Venezuela and their diasporic connection to Ewe Music`, `SEBASTIAN SUAREZ-SOLIS, DMA COMPOSER-PERFORMER, CALARTS`, `ANDREW GRUESCHOW, CO-DIRECTOR, WORLD MUSIC PERFORMANCE, CALARTS` ],
         press:[ `Links TBA` ],
         links:[ `Links TBA` ]},
        {id:4, slug:'fulia', title:'Fulia as an embodied product of space and placemaking', year:2025, type:'paper', tags:['paper', 'in-preparation', 'fulia', 'space', 'placemaking'],
         summary:`In preparation`,
         pic:'https://drive.google.com/file/d/15EusxODnOSmIPWn4G5VXYlhRtqCxh26C/view?usp=sharing',
         details:[ `The European folía phrase – coupled with Canarian folías, African cultural practice and indigenous lived experience – fused in modern Venezuela between the 16-20th centuries to form a syncretic cultural object called the fulía. This cultural object, during the nation’s republic era in the mid-to-late 20th century, was exported and commercialized to a transnational audience, both reinforcing and subverting notions of cultural hegemony. Ultimately, Afro-Venezuelan performances of fulía, whether sacred or secular, prove to be sources of communal entanglement and cultural resistance.`, `Through Gramscian and Lefebvrian lenses, the preservation of these oral traditions by community leaders is observed as 1). a subaltern rejection of cultural hegemony and subsequent assertion of an alternative good sense, and`, `2). a reclamation of the processes of the production of space.`, `Keywords: fulía, folía, Barlovento, Caracas, tambor, production of space, placemaking, Tambor Urbano, cultural hegemony, subaltern` ],
         credits:[ {role:'Advisors', name:'Sam Crawford, Volker Straebel'} ],
         press:[  ],
         links:[ {label:'link1', url:'https://drive.google.com/file/d/1tL5-1PBkL47eB2kuF2-lQOgJt4jrFDxy/view?usp=sharing'} ]},
        {id:5, slug:'gptosc', title:'GPTOSC', year:2025, type:'program', tags:['project', 'OSC', 'score', 'installation'],
         summary:`OSC protocol for ChatGPT-generated chamber score; performance score and installation instructions`,
         pic:'https://drive.google.com/file/d/1l8EkUpYGESjBfyR8ho6XuNo6KKomh8w5/view?usp=sharing',
         details:[ `GPTs suck at creative work, but giving it data to spit out is easy. Let's turn that into something we can use musically, having it draw numbers and make musical decisions about events and timing. How might we use a GPT instance to actually make music, instead of 1) having it give us shitty bar chords/half baked music theory or 2) ripping other artists off?`, `If an LLM is just a prediction machine, then how can we use that to our advantage, i.e. to make iterative, loop-based improvisational works?` ],
         credits:[  ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=zssAp-ROfuQ'} ]},
        {id:6, slug:'constructions', title:'CONSTRUCTIONS', year:2025, type:'installation', tags:['installation', 'sculpture', 'performance', 'light'],
         summary:`Six sculpture performance installation; sod, steel, glass, plastic, grass, douglas fir timber, LED/incandescent/low-pressure sodium-vapor light bulbs, LA streetlight fixtures c. 1970–2010; performance installation chamber symphony`,
         pic:'https://drive.google.com/file/d/1tzjDMlM5BYj0y00huq--qllsZnyHwU5X/view?usp=sharing',
         details:[ `light without color`, `CONSTRUCTIONS is a spatiodynamic installation where industrial light sculptures become instruments of time, perception, and material resonance. 6 hand-fabricated sculptures using steel, acrylic glass, timber, sod, soil, and three kinds of light sources (incandescent, LED, and low-pressure sodium vapor) change our perception of space and color through a light-based performance using internet-based relays. 5 performers use the relays to "play" the sculptures by turning them on and off remotely.`, `Initially performed as a symphonic work for sonic sculptures, the installation explores illumination and its inverse, revealing the technological architectures that mediate movement, space, and placemaking. Salvaged high-intensity discharge streetlamps from Palomar, CA, bear the histories of their function, marking shifts in industrial fabrication and civic planning. These lights impose on you a perceptive monochromy, collapsing color into shadows and textures, constructing space itself. This constriction, far from an erasure, produces an intensification: textures heighten, shadows sharpen, and objects lose their categorical immediacy.` ],
         credits:[ `construction, Sebastian Suarez-Solis` ],
         press:[ {url:'https://constructionsdmayear2recitalby.splashthat.com/'} ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=YVLwwSe4m9I&t=4s'} ]},
        {id:7, slug:'no-neutral-spaces', title:'NO NEUTRAL SPACES: How Placehood Creates Subjectivities', year:2024, type:'paper', tags:['paper', 'in-preparation', 'space', 'placehood'],
         summary:`In preparation`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:8, slug:'amps-marimba', title:'AMPLIFICATIONS: I. marimbaideefixe', year:2024, type:'composition', tags:['composition', 'marimba', 'solo'],
         summary:`for solo piano-amplified marimba`,
         pic:'https://drive.google.com/file/d/1oBaSxMClAALmaFSVxbkWO-SQKxQ8i097/view?usp=sharing',
         details:[ `transcription/recreation of track 1 on Amplifications (2024) album.` ],
         credits:[ `seb suarez, marimba`, `paul yorke, tim feeney, consult` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.com/#w/amplifications'} ]},
        {id:9, slug:'feedback-music', title:'feedback music', year:2024, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'https://drive.google.com/file/d/1RZZFL_8cm1AIwDdXDPHBLuzECEs20Ed2/view?usp=sharing',
         details:[ `* VOLUME WARNING: these tracks are based around exploiting feedback as an acoustical phenomenon, and as such, are quite loud and vary greatly in dynamics (often suddenly). While most tracks can be mastered well to avoid such moments, tracks with an asterisk are minimally mastered to preserve their waveforms. Mastering often involves use of limiting and compressing, and if I want to present the qualities of the waves (either sonically or, more important, visually) they cannot be limited. It would not look right, which is important for the WYSIWYG oscilloscope visuals. Other times, the sound of the feedback is itself clipping and distorting, and limiting that distortion would quiet the characteristics of the sounds I am trying to present. Listen with caution, lower your volume.`, `†Some tracks feature visuals, which are recommended for a first listen and are available with the included packet (available 03/01/2024).`, `_______________________`, `a collection of sounds and video exploiting acoustical feedback. all tracks are live recordings of captured feedback. any distortion you hear is caused in situ.`, `in Cyber-Theremin I & II, i turn my laptop into a feedback machine by running a patch through my computers microphone and speakers at the same time (+video).`, `in Squaring the Circle, i use sine waves in a custom 7-limit a''=415 temperament to paint shapes on a lissajous oscilloscope (+video).`, `in Mixer, with and without input, a no input mixer set meets input.`, `in Plate I & II, i use metal plates to create reverb and feedback. in the first, i take a thin sheet of metal (presumably aluminum) and attach two exciters to it. the exciters are fed directly to to a microphone, which is sometimes stationary, sometimes moving about the body of the plate. in Plate II, I run the same setup through a heavier metal plate, playing a piano through persistent feedback to cause live bitcrushing. there is no artificial bit reduction applied, either digitally or electronically. What you are hearing is acoustically generated, occurring in physical space.`, `in pia/o (pronounced like the instrument), a piano signal is fedback into itself through a controlled exploitation of hearback monitoring. the piano was recorded hot intentionally, so as to cause distortion. monitors were placed on the piano body, which reverberate the distortion, which the mics pick up, feeding back upon itself.` ],
         credits:[ `released February 26, 2024`, `sebastian suarez-solis, audio, video, editing, mixing, mastering`, `Recorded February 2024 Digital Recording Studio, CalArts, Santa Clarita, CA.`, `1. & 12. Created on a VCV Rack 2 Free patch “Sound Follow” by Sebastian Suarez-Solis. Uses modules Chronoblob2 by Alright Devices`, `Modal Synthesizer by Audible Instruments`, `Black Octasource by Erica Synths`, `PRESSOR by Bogaudio`, `Supercell by Grayscale`, `Sunflower and Wilt by NOI`, `Ice Tray by Path Set`, `Audio, Audio 8, Logic, and Recorder by VCV. This patch utilizes various freeware and software under the GNU General Public License v3.0 or later. The patch is also under the GPL-3.0-or-later license.`, `2. Video created using Oscilloscope II by Hansi Raber.`, `some rights reserved` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.bandcamp.com/album/feedback-music'} ]},
        {id:10, slug:'amplifications', title:'Amplifications', year:2024, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'https://drive.google.com/file/d/1oBaSxMClAALmaFSVxbkWO-SQKxQ8i097/view?usp=sharing',
         details:[ `a series of improvised compositions, utilizing multiple pianos as resonating bodies to extend the sustain of various instruments. with various metal implements scattered throughout the piano bodies, the strings sympathetically reverberate along to the improvisatory sounds of each instrument, at times a whisper, at times a roar.`, `microphones are placed inside the body of the piano capturing a large, harmonious reverberation, a ghostly chamber ensemble of one.` ],
         credits:[ `eleased October 16, 2023`, `marimba, viola da gamba, music box, multiple percussion, desk bells, sebastian suarez-solis`, `audio, sebastian suarez-solis`, `photo, sebastian suarez-solis`, `recorded at California Institute of the Arts on Oct. 13-15, 2023.` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.bandcamp.com/album/amplifications'} ]},
        {id:11, slug:'miles-davis', title:'Miles Davis, Paul Buckmaster, and Teo Macero at 50: A Retrospective Reclamation of ‘Jazz’s Most Hated Record’ (with Enrico Merlin)', year:2023, type:'paper', tags:['paper', 'in-preparation', 'jazz', 'history'],
         summary:`In preparation`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:12, slug:'cybernetics-dialectics', title:'Cybernetics, dialectics, and phenomenology in the works of Sebastian Suarez-Solis composed during 2022-2023', year:2023, type:'thesis', tags:['thesis', 'composition', 'peabody'],
         summary:`MM Music Composition, Peabody Institute of the Johns Hopkins University`,
         pic:'',
         details:[  ],
         credits:[ {role:'Mentors/special credit', name:'Sky Macklay, Oscar Bettison, Michael Hersch, Felipe Lara'} ],
         press:[  ],
         links:[ {label:'link1', url:'https://catalyst.library.jhu.edu/permalink/01JHU_INST/t3c16/alma991060710320007861'} ]},
        {id:13, slug:'redacted', title:'█████', year:2023, type:'score', tags:['score', 'graphic', 'chamber'],
         summary:`open chamber graphic score based on redactions of other texts`,
         pic:'https://drive.google.com/file/d/1GFCkwba_3Jf1-ei43S76hYEp554u4LDn/view?usp=sharing',
         details:[ `38 page digital graphic score based on the redaction of a previous solo piece, meant to be viewed in page spread (2 page) view. Be sure to align pages per performance note instructions. Temporality is no singular object in this score, as players may start and end wherever they please.` ],
         credits:[ `written for Hub New Music at CTSF 2023` ],
         press:[  ],
         links:[ {label:'premiere', url:'https://www.youtube.com/watch?v=Rfiauh0IJ44&t=5064s'}, {label:'recording', url:'https://www.youtube.com/watch?v=sps0_izRRUw'} ]},
        {id:14, slug:'synesdoche', title:'SYNESDOCHESYNTHESTHESIS', year:2023, type:'score', tags:['score', 'tactile', 'visual', 'messiaen'],
         summary:`tactile visual score based on Messiaen’s Modes of Limited Transposition`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:15, slug:'light-study-a', title:'Light Study A', year:2023, type:'installation', tags:['installation', 'light', 'stochastic', 'sculpture'],
         summary:`temporary parthenon sculpture modification; stochastic light sculpture`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:16, slug:'light-study-b', title:'Light Study B', year:2023, type:'installation', tags:['installation', 'light', 'stochastic', 'sculpture'],
         summary:`stochastic light sculpture`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:17, slug:'valence', title:'valence', year:2023, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'https://drive.google.com/file/d/1nmympHmAmdGjD1yBCCNMKuT63JRgrrey/view?usp=sharing',
         details:[ `A series of improvisations on two side-by-side Soma Pulsar-23 synthesizers. At times their clocks are connected, at times they are not, creating both strict and free polyrhythms. The album is divided into three parts, presented as three structures. These structures are full-length, uncut improvisations (mostly), split into tracks, which gradually change and morph over the course of the structure's construction.`, `The machines' delay outs are wired to each others' delay ins for a harmonious filtered delay feedback. Often times, envelopes from one device are sent to the other to make organic rhythms out of the control voltage from one module, using fundamental beat patterns (4 on the floor, tresillo, etc) as a source rhythm. The Pulsar-23 synthesizers are really quite adept at making IDM/EDM.` ],
         credits:[ `released November 5, 2023`, `audio, sebastian suarez-solis`, `photo, sebastian suarez-solis`, `Recorded at CalArts on Nov. 3-4, 2023`, `license`, `some rights reserved` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.bandcamp.com/album/valence'} ]},
        {id:18, slug:'string-theory', title:'String theory', year:2023, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'https://drive.google.com/file/d/1W4s6G0IjohiJ5XpLWiHII2c7e5rHWFNQ/view?usp=sharing',
         details:[ `The third album of cybernetic harpsichord music from Sebastian Suarez-Solis. Presented as one sonic event, this offering explores new terrain on the harpsichord through old school time-stretching techniques. An improvisation of improvisations, there is no barrier between composition and extemporization. Thirty minutes of harpsichord improvisation (on the keys and on the strings, with electronic bows and other preparations) are layered, manipulated, and stretched by several orders of magnitude to creeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaatttttttttteeeeeeeeeeeeeeeee aaaaaaaaaaaaaaaaaaaaa fffffeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeelllliiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiinnnnngggg ooooooooofffff eeeeeeeeeeeeeeeellllaaaaaaaaaaaaaaaaaaaaaaatttteeeeeeeeeeeeddddddddddddddd ttttttrrrrrrrrrrrrrrrrrraaaaaaaaaaaaaannnnnnnnnnnnnnnnnnnssssssccccccccccceeeeeeeeeeeeeennnnnnnddddddddddddeeeeeeeeeeeeeeeeeeeeeeeeeeeennnnnnnnnnnnnccccccceeeeeeeeeeeeee`, `LISTENING INSTRUCTIONS`, `listen super loud, please, with some headphones or some speakers.`, `this album is meant to be heard in order` ],
         credits:[ `released August 23, 2023`, `harpsichord, sebastian suarez-solis`, `audio, sebastian suarez-solis`, `recorded and produced in baltimore, md`, `some rights reserved` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.bandcamp.com/album/string-theory'} ]},
        {id:19, slug:'short-drones', title:'SHORT DRONES', year:2023, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'https://drive.google.com/file/d/1Qu61dZicOgReSfD6TiXjKi3aep7dNWaP/view?usp=sharing',
         details:[ `4 short (less than 5 minute) pieces of music featuring drones, largely static in harmonic content, from samples of prepared harpsichord, modular synthesizer (VCV Rack 2), and organ.`, `LISTEN LOUD AND IN ORDER // each piece transitions directly into the next`, `---`, `drone i: harsh noise and heavy bass meet harpsichord drones`, `drone ii: harpsichord drones with electronic percussion`, `drone iii: harpsichord drones with noise`, `drone iv: harpsichord drones meets electronics, sampled organ drones, and sampled harpsichord.` ],
         credits:[ `released August 18, 2023`, `prepared harpsichord, sebastian suarez-solis`, `this work uses samples from dex digital sample library, including:`, `prepared harpsichord, sebastian suarez-solis`, `organ, midori ataka`, `for more info, visit dexdsl.com/copyright`, `album cover, sebastian suarez-solis`, `artwork, tyler jordan, thomas milovac, sebastian suarez-solis`, `for`, `syoma flora`, `thomas milovac`, `tyler jordan`, `cameron church`, `ruby fulton`, `paul* hermansen`, `sky macklay`, `meg huskin`, `paul yorke`, `midori ataka`, `eden knight`, `kings leery`, `santiago suarez-solis`, `tirone orama` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.bandcamp.com/album/short-drones'} ]},
        {id:20, slug:'free-temper', title:'Free Temper', year:2023, type:'album', tags:['album', 'bandcamp'],
         summary:`Bandcamp`,
         pic:'https://drive.google.com/file/d/1MZZRt-bG8d-MlmjxrG63KyNbFIuBPP-x/view?usp=sharing',
         details:[ `an improvisation of new techniques on the harpsichord, in free temperament. long live the liberated notes.` ],
         credits:[ `released August 5, 2023`, `prepared harpsichord - sebastian suarez-solis`, `audio - sebastian suarez-solis`, `some rights reserved` ],
         press:[  ],
         links:[ {label:'link1', url:'https://cbassuarez.bandcamp.com/album/free-temper'} ]},
        {id:21, slug:'meta-improvisation', title:'meta-improvisation no. 1', year:2022, type:'fixed media', tags:['looped video', 'video', 'improvisation'],
         summary:`video installation remixing gamba samples`,
         pic:'https://drive.google.com/file/d/1pMT1MgQrj6fZlVcG-6SpSGOtLJm4o9Z2/view?usp=sharing',
         details:[ `an improvisation of improvisations.` ],
         credits:[  ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=e39f4tJuAXg'} ]},
        {id:22, slug:'rasga', title:'Rasga', year:2022, type:'composition', tags:['composition', 'theorbo'],
         summary:`for theorbo`,
         pic:'https://drive.google.com/file/d/1avnPJOcTFo4M18bsHftbi5g9EhBQQWii/view?usp=sharing',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:23, slug:'seven-sounds', title:'Seven Sounds for Strings', year:2022, type:'composition', tags:['composition', 'harpsichord', 'prepared'],
         summary:`for prepared harpsichord`,
         pic:'https://drive.google.com/file/d/1mX00RYol3qQOzyIVjLzAfwKfD3OKMx1e/view?usp=sharing',
         details:[ `THIS IS NOT BAROQUE MUSIC. THIS IS NOT RENAISSANCE MUSIC. THERE IS NO COUNTERPOINT. THERE ARE NO LINES. THIS IS NOT COMMON PRACTICE PERIOD. THIS IS NOT AN ACT OF CREATION. THIS IS NOT IMPROVISATION. THIS IS NOT UNFOCUSED. THE MESSAGE IS CLEAR THE MESSAGE IS CLEAR THE MESSAGE IS CLEAR: LA PATRIA VIVE EN ESTE ACTO DE DESTRUCCIÓN` ],
         credits:[ `published on scorefollower Follow My Score Fall 2022` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=DAj6pGOpWp8'} ]},
        {id:24, slug:'pasos-invisibles', title:'pasos invisibles', year:2022, type:'score', tags:['score', 'sculpture', 'continuo'],
         summary:`sculpture score for continuo and at least one other player`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:25, slug:'live-election-bingo', title:'LIVE ELECTION BINGO', year:2022, type:'composition', tags:['composition', 'fixed', 'interdisciplinary'],
         summary:`fixed composition of a week’s worth of music, sculpture, and painting`,
         pic:'https://drive.google.com/file/d/1lFB8fogURevIJ1Lj4g2uvOsoZRvcJk_z/view?usp=sharing',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:26, slug:'hapax', title:'Hapax Legomenon', year:2022, type:'composition', tags:['composition', 'ensemble', 'theatrical'],
         summary:`for lipsynching ensemble`,
         pic:'https://drive.google.com/file/d/1TqH6o6SuvZG0HIYX6zB5vTUCQlCVu45j/view?usp=sharing',
         details:[ `hapax legomenon, (n): a word or form occurring only once in a document or corpus.`, `etymology: greek, something said only once.`, `– accessed on merriam-webster.com on 09/26/22` ],
         credits:[ `written for and premiered by ensemble dal niente for their Peabody residency fall 2022` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=hJEXoEWMLiA'} ]},
        {id:27, slug:'mere-particle', title:'mere particle of a machine, with less will', year:2022, type:'composition', tags:['composition', 'MaxMSP', 'acoustic'],
         summary:`for acoustic instrument & MaxMSP patch (1–2 players)`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:28, slug:'string-quartet-2', title:'String Quartet No. 2 “soundnoisemusic”', year:2022, type:'composition', tags:['composition', 'string-quartet'],
         summary:`string quartet`,
         pic:'https://drive.google.com/file/d/1jO4a7PCDKzamQqSJbGlSUJOUVJOkpyOZ/view?usp=sharing',
         details:[ `Every other performance, this piece is entirely improvised. Every other performance, the performers follow the through-composed score. Every other other performance, this piece is played at 80% intent and 50% resentment. Every other other other performance, the members of this piece trade parts. Every 10 performances, the members of the ensemble are playing a cruel joke on the composer and the audience. Every 12, the 5th page of every part is swapped for a page from one of J.S. Bach’s Sonatas or Partitas for Violin. On any performance where it is the ensemble’s second time performing that day, the music is to be read in retrograde inversion. Every peformance indoors must be done at double tempo. In the event that performers were not fed prior to performing, they may play noise wherever they may choose.`, `If you cannot tell the difference if you cannot beat ‘em join ‘em then does it even matter?`, `---`, `"Heard melodies are sweet, but those unheard`, `Are sweeter`, `therefore, ye soft pipes, play on`, `Not to the sensual ear, but, more endeared,`, `Pipe to the spirit ditties of no tone:"`, `John Keats, “Ode on a Grecian Urn”, lines 11-14` ],
         credits:[ `written for parker quartet for their peabody residency fall 2022.`, `Premiered by Parker Quartet at the Peabody Institute of the Johns Hopkins University, Leith Symington Griswold Hall, September 13, 2022.` ],
         press:[  ],
         links:[ {label:'link1', url:'https://soundcloud.com/cbassuarez/snm?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing'} ]},
        {id:29, slug:'great-dane', title:'great dane', year:2022, type:'composition', tags:['composition', 'piano-trio'],
         summary:`piano trio`,
         pic:'https://drive.google.com/file/d/1PBVgJDDekiAqImBBw6ca2WVXTFF0co1n/view?usp=sharing',
         details:[ `i remember the last time i saw you.`, `i was driving, the city filled to the brim with life,`, `bursting at the seams, ready to rupture, teeming`, `the streets full of people,`, `food, friendship, and follies,`, `grit, broken glass, the great steeple`, `ringing, one bell later than the others,`, `cars passing, one ways one way, bi-ways the other way,`, `with one great dane prancing between sidewalk and asphalt.`, `it was april, yet the cold would lap up at your ankles`, `and consume you before you knew it.`, `it was unusual for this time of the year`, `it would happen every couple of weeks and settle down eventually.`, `it ran fast, the legs outstretching the body, overtaking its pace`, `and scrunching up, like a spring of flesh and sinew.`, `i wouldn’t have imagined this to be the last big chill –`, `not a sign of slowing, but cold is warm enough.`, `it was fast. really fast`, `straight into a car it ran.`, `it’s as if it didn’t know it was dead yet, it kept running.`, `as if the cold was a cruel anesthetic`, `we locked eyes, the second law granting this creature a momentary reprieve`, `when its muscles twisted... a moiety of bone and bloody foam...`, `...caught between forming a next stride and giving way to that incalculable force.`, `i called you. i called for you.`, `you said you were never there for me and I apologized.` ],
         credits:[ `premiered by trio immersio`, `Performed at the Peabody Conservatory on Oct. 15, 2022 by Sangwoo Kim (v), Alberto Macias (c), and Arin Shahjahanian (p)` ],
         press:[  ],
         links:[ {label:'link1', url:'https://soundcloud.com/cbassuarez/great-dane-piano-trio-october-2022-performance'} ]},
        {id:30, slug:'string-quartet-1', title:'String Quartet No. 1', year:2022, type:'composition', tags:['composition', 'string-quartet'],
         summary:`string quartet`,
         pic:'https://drive.google.com/file/d/1WSpcO24VCjq-ZIzU3ub-Gu_UYKIHxoaN/view?usp=sharing',
         details:[ `mnemonic-neumatic string quartet based on the phonemes of the Pledge of Allegiance. written for mivos quartet for VIPA.`, `description: from Alexandra Teague’s America the Beautiful: Thriftstore, lines 10-20, 31-35`, `fuzzy gloves with pom poms and pockets with real dimes for free`, `and ticket subs to movies that sound like a good idea of your past–`, `like maybe that night got lost when this coat did and now you have your hands`, `in its silk lining like you were born here in this America`, `where everyone is safe as plastic tumblers and day-glo salad spinners`, `and no one cares if you walk the aisles in two different shoes like the man`, `in that children’s book with so many caps on caps on caps on his head`, `you remember no more story like “America the Beautiful”`, `was only ever purple mountains crayoned so hard the paper wrapping`, `had to be peeled back because patriotism meant sacrificing`, `monarchs and thrones and majesty and one color to rule them all`, `...`, `that majesty of the already-gone but refillable like a bin of hats`, `which maybe was the whole story how the man carried`, `all of them with him like a country that erects monuments`, `not only for presidents but also for this-man-was-lynched-hereand-`, `now-there’s-a-swingset` ],
         credits:[ `performed by mivos quartet` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=Fv61zEUfoZI'} ]},
        {id:31, slug:'madre', title:'madre, de mar, darme', year:2022, type:'composition', tags:['composition', 'jazz-orchestra'],
         summary:`suite for jazz orchestra and improvisatory conductor`,
         pic:'',
         details:[ `For now, while we can – perchance? –`, `\\we will, we’ll dance as if it’s all we’ve left (sin).` ],
         credits:[ `written for TORCH Collective for the 2022 Common Tone New Music Festival` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=QBVhhNfrysc&embeds_referring_euri=https%3A%2F%2Fcbassuarez.com%2F&source_ve_path=OTY3MTQ'} ]},
        {id:32, slug:'sonata-for-saxophones', title:'Sonata for Saxophones', year:2022, type:'composition', tags:['composition', 'saxophone-quartet'],
         summary:`saxophone quartet`,
         pic:'https://drive.google.com/file/d/1mjVLM-1wxFvEGzGLM6Ew4K9xpXvGT9R5/view?usp=sharing',
         details:[ `THIS SONATA IS:`, `| A LIVE DIALOGUE`, `| AN INTERRUPTED RADIO BROADCAST`, `| A FLIGHT OF FANCY`, `| DERIVATIVE`, `| A SILENT SCREAM`, `| NOT GOING TO TALK ABOUT IT`, `| WOW AND FLUTTER`, `| A RIOT`, `| A BROKEN CASETTE ON A FAILING CASETTE PLAYER`, `| TAKING ITSELF WAYYY TOO SERIOUSLY`, `| THE LAST REMAINING ORIGINAL BAROQUE WORK, WITH SOME ERRATA`, `| | 18TH CENTURY MUZAK`, `| | IN BINARY FORM`, `| CORRUPT, VULGAR`, `| NON-EUCLIDEAN`, `| TOO SHORT`, `| | TOO LONG`, `| | TOO GOOD`, `| |TOO BAD`, `| | | NOT ENOUGH`, `| | MAKING THE BEST OF A BAD SITUATION`, `| | NOT BASED ON ANYTHING`, `| INTRUSIVE THOUGHTS`, `| |UNCONSCIOUS, AUTOMATIC, REFLEXIVE`, `| | REVISIONARY, THOUGHTFUL, INTROSPECTIVE, CONSCIOUS`, `| ORGANIZED`, `| | CHAOS`, `| WEIRD, NEW`, `| | OUTMODED, BEEN-THERE-DONE-THAT`, `| ???`, `| | !!!` ],
         credits:[ `written for and premiered by Estrella Consort for the Alba Composition Program` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=FZuBIflF5Ns'} ]},
        {id:33, slug:'corriente', title:'MALLET QUARTET No. 1 “Corriente”', year:2022, type:'composition', tags:['composition', 'percussion', 'graphic-score'],
         summary:`graphic quartet for two vibraphones and two marimbas`,
         pic:'https://drive.google.com/file/d/1ZtgLtLWjBrIKd34Wux142YKu2JPBr8Wj/view?usp=sharing',
         details:[ `corriente (spanish): adj`, `1. frequent, happening often`, `2. habitual`, `3. not special, common`, `4. running, flowing`, `noun (fem.)`, `1. current [of fluid]`, `2. draft [of air]`, `3. current [of electricity]`, `4. tendency`, `1. trend, movement`, `noun (masc.)`, `1. informed`, `2. up to date`, `corre corre corriente corro como corren coro quiero que yo quedo miedo queden puedo suedo credo pero el no hell no well go and try to be the very best you can be: si no puedes no trates no quieres no mandes si no son no son no ron ni melocoton, toston, o no trueno en pleno se no si no soy sí voy estoy la doy no traigo nada cada lado estancado exprimido sido ído hipo tipo pero si y no y él y ella y en ellos cualqui-ellos son que quieren que te tetero te quiero todo toro torre forro todo y – corre corre corre coooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo:ooooorrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr:rrrrrrrrrrrrieeeeeeeeeeee:eeeeeeeeee:eee:e eleison – cuenta‘l coro: ¡muerte muerte mala suerte corre corre como la corriente! ¡muerte muerte mala suerte como hombre causa muerte! ¡tiroteo bombardeo desempleo no lo creo! c cc cccc ccccccccorrrrrrrrrriennnnntttttttt` ],
         credits:[ `performance by Ben Giroux, AJ Hudson, Ganguk (Karl) Lee, Hyunwoo Kim, Peabody studio percussionists. a/v by Ben Giroux.` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=UiA5gDmFzhE&embeds_referring_euri=https%3A%2F%2Fcbassuarez.com%2F'} ]},
        {id:34, slug:'double-concerto', title:'Double Concerto for Violin and Percussion “Sonata da Camera”', year:2022, type:'composition', tags:['composition', 'concerto', 'violin', 'percussion'],
         summary:`(2022–) for violin, 3 percussionists on 6 amplified film cameras, film technicians, and orchestra`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:35, slug:'20-symphony', title:'$20 Symphony', year:2022, type:'composition', tags:['composition', 'game', 'large-group'],
         summary:`a game of greed for any large group`,
         pic:'',
         details:[  ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:36, slug:'meditation', title:'Meditation', year:2022, type:'composition', tags:['composition', 'orchestra'],
         summary:`for orchestra`,
         pic:'https://drive.google.com/file/d/1RbrdskP8fZSH0VpHIDcjr7Q2sLU43Q4h/view?usp=sharing',
         details:[ `ablation of the self ... choose ... rules. ... power structure ... implanted will and a manufactured consent ... . conductor is now not the only ... but also has their own improvisatory moments. ... vulnerable ... limitation ... liberation of the ... players ... every structure ... its own consequences ... own voice. ... communal improvisation ... a self-unfolding dialectic diorama... conductor as performer ... performer as listener ... a time for collective action!` ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:37, slug:'toma-aire', title:'Toma Aire', year:2021, type:'composition', tags:['composition', 'flute', 'one-breath'],
         summary:`for flute, to be performed in one breath`,
         pic:'https://drive.google.com/file/d/1tmj7Y8SNJB8meoSZX2QfFE9lkXBiltCS/view?usp=sharing',
         details:[ `sei solo…`, `…ma almeno è un solo respiro!` ],
         credits:[ `performed by Kathryn G. Willaims at Leeds University, London` ],
         press:[  ],
         links:[ {label:'audio: https://drive.google.com/file/d/1eB5O4gJXcwYPZLX7sboSfiMivuRyC5tq/view?usp=sharing, pdf', url:'https://drive.google.com/file/d/1lE-cjpv_2BN0_nApIuNdcSfItuh4W-mO/view?usp=sharing'} ]},
        {id:38, slug:'socorro', title:'socorro', year:2021, type:'composition', tags:['composition', 'saxophone'],
         summary:`for soprano saxophone`,
         pic:'https://drive.google.com/file/d/1PKCzsCGf-DWN2gxXTNyj0Jev3WlXfKFE/view?usp=sharing',
         details:[ `commissioned by Jade Deatherage` ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:39, slug:'gems', title:'GEMS', year:2021, type:'composition', tags:['composition', 'theatrics', 'solo'],
         summary:`twelve theatrics for any soloist`,
         pic:'https://drive.google.com/file/d/1GfYfogST8JY_dbmoZfZvey1LmLYOhohb/view?usp=sharing',
         details:[ `GEMS is a set of twelve miniatures that explore theatrical elements of the contemporary musical stage performance practice. Each miniature, a different “gem” in its own regard, delves into the more uncomfortable, comical, and puzzling aspects of being on stage (and, as a corollary, being an audience member).`, `These miniatures may be performed all together, as one set of actions (in which case movement titles are not encouraged for programming), or they may be used to bookend other repertoire for a performance.` ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:40, slug:'dynamo', title:'dynamo', year:2021, type:'composition', tags:['composition', 'ensemble'],
         summary:`for 3 or more players with the help of 2 assistants`,
         pic:'https://drive.google.com/file/d/1nbUspP97gCTsXfbPcZncPMzlgaB41dTl/view?usp=sharing',
         details:[ `dynamo is performed using a physical medium only, and requires a projector, a table and streaming equipment in order to fulfill the roll of the visual assistants and preserve the game-like structure of the piece. a perusal score is available (with no performance license)`, `dynamo is a suite for any number of players, with the help of two assistants, based on the music, world-building, and game design of popular role-playing video games. the piece is a marriage of music, interactive game design, and visual art: the piece is printed on a 24”x132” tapestry. during a performance of dynamo, the 11-foot tapestry is draped across the stage, dragged over a table which is under either a projector or camera, displaying the music to both the audience and the players. the performers are free to play any cell projected and free to repeat ad libitum, while the assistants are free to drag forward the “world boundary” the players play on at their leisure. each movement explores different tropes of both role-playing video game landscapes and their related soundtracks, as well as different tropes of minimalist and graphic score design.` ],
         credits:[ `performed by Mind on Fire in Baltimore, MD` ],
         press:[  ],
         links:[ {label:'Mind on Fire performance', url:'https://www.youtube.com/watch?v=3P0uTctRQeU&list=RD3P0uTctRQeU&start_radio=1&pp=ygUdZHluYW1vIHNlYmFzdGlhbiBzdWFyZXogc29saXOgBwE%3D'}, {label:'UCF Recording', url:'https://www.youtube.com/watch?v=XqP1RAv40Rs&list=RDXqP1RAv40Rs&start_radio=1&pp=ygUdZHluYW1vIHNlYmFzdGlhbiBzdWFyZXogc29saXOgBwE%3D'} ]},
        {id:41, slug:'prisma', title:'PRISMA: Book of Moves', year:2021, type:'composition', tags:['composition', 'quartet', 'theatrical'],
         summary:`a suite for theatrical quartet`,
         pic:'https://drive.google.com/file/d/1WDfKL6HdAfh9p1Bq6Y40ex0BuprUusCS/view?usp=sharing',
         details:[ `PRISMA: Book of Moves is an instrumental and theatrical production scored for a theatrical quartet - that is, a group familiar both with that which is musical and that which is dramatic. With instruments strewn about stage as a makeshift set, the troupe sets off to perform. This piece examines the standards of dramaturgical movement and their context within the standard musical practice, using popular tropes of modern horror movies to create the juxtaposition. In doing so, the piece questions the nature of performance (from the dramaturge’s perspective), the initial presentation of the quartet reminiscent of the “in medias res” tropes into which horror movie characters get written. In this way, the quartet’s performance is unexpected to them, as if they just woke up backstage and forced to perform a piece - PRISMA -  about optics and colors. That is to say, the group of performers is acting as another group of performers, led on stage to play a piece for the first time, the rest of the surrounding details a mystery.`, `The performers set off on their journey, wary to read instructions carefully, but over time, disrespect the music by either failing to execute directions properly, being too scared of messing up, intentionally disregarding risky text, or later, by beating and dismembering the score. Soon enough, however, some of the details surrounding the link between the music and the performers are uncovered… or better yet, brought to life.` ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:42, slug:'meditations-on-change', title:'Meditations on the Nature of Change', year:2021, type:'composition', tags:['composition', 'concerto', 'percussion'],
         summary:`concerto for a theatrical percussionist`,
         pic:'',
         details:[ `“What I possess in my consciousness is for me. ‘I’ is this void, the receptacle for anything and everything, that for which everything exists and which stores everything within itself. Every human being is an entire world of representations buried in the night of the ‘I.’ The ‘I’ is thus the universal in which abstraction is made from everything particular, but in which at the same time everything lies shrouded. It is therefore not a merely abstract universality, but a universality that contains everything within itself.”`, `–G.W.F. Hegel`, `this piece was written to satisfy a (both academic and personal) requirement in my senior percussion recital at the University of Central Florida. it was written during a time where i was facing my final semester of my Bachelors and witnessing a metamorphosis of self`, `this was, incidentally, also a time where i was at an intersection of philosophies. i had picked up a knack for Hegel, as well as the films of Francois Truffaut, Jacques Tati, and Jean-Luc Godard, but i had also began reading the words of the Buddha. this resulted in an ablation of my “self,” as i saw it. if had earlier presumed that the self does not exist, this presumption was validated by the dialectical theory i had consumed. i reconciled the lack of a self with the unity of community, this piece being an extant listing of my findings, in a self-aware hybrid play/musical performance format.`, `the concerto is for solo percussionist, who plays snare drum, zarb, sings, and plays the stage itself, amongst other improvisatory acts. accompanying the soloist is three percussionists, and an actor, who plays the part of “The Self,” a personification and literal embodiment of the concept of a “self.” throughout a prologue, three movements, and an epilogue, the troupe explores change, leaving home (and your legacy thereafter), and identity.`, `"we join our performers as they first encounter each other, colleagues and already lifelong friends. they begin a journey through themselves and the world around them`, `namely, they explore how relationships define us, and how change affect us all. ...how change can inspire us, deplete us, scare us, temper us, and what it means to will your own change. this, this moment is their meditation... on their nature, our nature.”` ],
         credits:[ `seb suarez, solo`, `christian de la torre, p1`, `christina smith, p2`, `michael mortilla, p3`, `ema pava, narrator` ],
         press:[  ],
         links:[ {label:'link1', url:'https://soundcloud.com/cbassuarez/meditations-on-the-nature-of-change'} ]},
        {id:43, slug:'synchrony', title:'Synchrony: A Symphony of Theatrics', year:2021, type:'composition', tags:['composition', 'symphony', 'large-group'],
         summary:`for any large group`,
         pic:'https://drive.google.com/file/d/1m5GlpoV5uXrQVCoPypWucG9K1Xv47G_r/view?usp=sharing',
         details:[ `Synchrony is a symphony for a large group consisting of any instruments and consorts, of any size between 12 and 50 members. The piece takes its name from the orbital, atomic, mechanical, and otherwise natural phenomena observed to move in synchronized behavior (such examples include the synchronization of metronomes on a suspended table, the rings of Saturn, the quantum synchrony of “phase oscillators” in the field of quantum physics).`, `The first movement is focused on species of fireflies that glow in general synchrony. Like the fireflies, players - using theatrics - communicate to each other over time, multiple vectors gradually coming into phase with each other. Over the course of the rest of the symphony, similar structures of chaos and subsequent phase alignment are explored, with differing initial conditions.` ],
         credits:[  ],
         press:[  ],
         links:[  ]},
        {id:44, slug:'ffwl', title:'Films from Wooded Landscapes', year:2020, type:'composition', tags:['composition', 'vibraphone', 'film'],
         summary:`for prepared vibraphone and film`,
         pic:'https://drive.google.com/file/d/1xaEN5zdC4yzYBg8BZuJpxhmV9_lYGNs-/view?usp=sharing',
         details:[ `the idea for this piece came to me through the acquisition of some video gear. preparing for some future video projects, i took to local forests with friends, capturing moments of awe and interconnection. in a way, this project also came out of longing for a connection with the nature of the greater Orlando area before I left for graduate studies. film needed to be an integral part of the undertaking, as i wanted a perceptible medium to remember the nature that inspired the work. each movement of Films is accompanied by a film à clef - two each with a cherished friend, one on my owncapturing the nature of the cities in which my friends and I live. the music and, especially, the instrumentation, lend a weightless, unanchored quality to the film. overall, both mediums work together to provide the experience which i like to describe as “seeing moving pictures at a gallery” (and at one point, incredibly early on, the “gallery audience” is revealed slightly).` ],
         credits:[  ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=qAYNKc-cAr4'} ]},
        {id:45, slug:'asaf', title:'A Scene and Fantasy', year:2020, type:'composition', tags:['composition', 'horn'],
         summary:`a solo piece for horn in two parts: first movement is a microtonal introit whose rhythm is derived from the meter of spoken word; second movement is a graphic score.`,
         pic:'https://drive.google.com/file/d/1QsAKb2SaOgY13ZQLAAhZpiEYAAQLYtUa/view?usp=sharing',
         details:[ `a scene and fantasy is the title of a poem i wrote in the summer of 2019`, `it explores the feeling of being in a room with others and suddenly realizing your mind is miles away, coming in and out awareness. in clearer terms: it aims to capture a narrators experience of dissociation, their attempts at pushing themselves back into the scene by noticing the room around them, and the dread they feel when they do finally snap back to their own thoughts and the reality around them. the scene is presented as fantastical snippets of one’s memory from the event, while the fantasy is shown as a scene the narrator dreams at the peak of his dissociative spell.`, `i found the horn to be a perfect voice for this feeling. it is warm and inviting, but when pushed to the extremes of its lower range, and allowing for some changes in intonation and embouchure, can sound quite discomforting. the text is set to the poem, mostly syllabically, as i want the meter of the poem and the rhythmic notation to work in tandem, and i want the words to guide the character of the piece as well. ultimately, every rhythm but what is marked march-like can and should be up to the performer to match to the meter and character of`, `i have adorned some notes with arrows, which are to raise or lower the pitch of that note by no more than 50 cents (a quarter-tone), which is to be done by changing the embouchure to suit. as well, there is some graphic notation being employed, which denotes a larger variance of pitch correspondent to the graphic’s location in pitch space.` ],
         credits:[ `cassian ramos, horn` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=fN0VGPENz8I'} ]},
        {id:46, slug:'alma', title:'alma mater', year:2020, type:'composition', tags:['composition', 'piano', 'ensemble'],
         summary:`for piano and twelve obbligato instruments`,
         pic:'https://drive.google.com/file/d/1UF0sXiQI9StHy9GM8mdynHPUoYHSCXXd/view?usp=sharing',
         details:[ `this piece was under the working title "Points of Recursion" for quite some time during my compositional process. it was a chance for me to really get acquainted with the process of automatic creation, or creating without any forethought or conscious direction. it was also an exploration in the phenomenology of ideas, and the power sharing an idea can have. at its crux, the piece was a celebration of our habits: the human being's fantastic ability to form trends over time based on experiences, the ability to soak up a person or place and form patterns around them. in many ways, we tend to focus on the moments of change, the rare things that happen to us. we look to those to define ourselves, when the habits and menial tasks we do day in and day out - the routes we take home, the sayings we say, the friends we speak to, the foods we eat, the music we listen to - are what actually define the majority of our lives. with all that in mind i sought to create the score and solo in one sitting, and ask the performers not to look though their part until the moment of performance (and even then i would ask not to sight read/read ahead).`, `i thought something was missing, however, and i knew the title was only temporary. when i finally got all my colleagues together and I was able to listen to a recording, i realized we had all shared similar emotions about our soon-to-be-ending studies at the University of Central Florida. i knew then what was missing was an homage to the sense of community i felt when recording, an undertone of what i experienced in my time at UCF. it is that very community which inspires drive, our habits and tendencies and we accept as our identity. alma mater is a celebration of the constantly evolving habits we form while under the nourishing arm of our community. i dedicated the title in great deference to UCF, and for all i have grown in my undergrad, for all that UCF and i will continue to change.` ],
         credits:[ `tiffany connell, piano solo`, `isabel aviles, flute`, `vincent artusa, oboe`, `maria jimena picado, clarinet`, `erika clippinger, bassoon`, `jin na jones, violin`, `jomar cruz, cello`, `coral navarre, trumpet`, `garrett gauvin caraballo, trombone`, `jessie otaiza, glockenspiel`, `christina smith, vibraphone`, `sebastian suarez-solis, marimba`, `christian de la torre, multiple percussion` ],
         press:[  ],
         links:[ {label:'link1', url:'https://www.youtube.com/watch?v=ECLw2gqASuA'} ]},
]
    };
    // sprite animations
(function spriteAnimateOnHover(){
  const root = document.getElementById('cb-console') || document.body;
  let el = document.getElementById('cb-sprite');
const canHover = matchMedia('(any-hover: hover)').matches;
const hasFinePointer = matchMedia('(any-pointer: fine)').matches;
const isFine = canHover || hasFinePointer;

  // 1) ensure the sprite exists
  if(!el){
    el = document.createElement('pre');
    el.id = 'cb-sprite';
    el.setAttribute('data-kind','note');       // default kind
    el.textContent = '♪';                     // tiny ASCII buddy
    root.appendChild(el);
  }

  // 2) one extra child (streetlight cone) when needed
  function ensureFxLayers(){
    if(el.getAttribute('data-kind')==='streetlight' && !el.querySelector('.fx-cone')){
      const cone = document.createElement('i');
      cone.className = 'fx-cone';
      el.appendChild(cone);
    }
  }

  // 3) render tiny ASCII per kind
  function render(kind){
    kind = (kind||'note').toLowerCase();
    el.setAttribute('data-kind', kind);
    if(kind==='note')        el.textContent = '♪';
    else if(kind==='streetlight') el.textContent = '│';
    else if(kind==='cursor') el.textContent = '▮';
    ensureFxLayers();
    scheduleFlicker(); // only runs for streetlight
  }

  // 4) hover/press (desktop only; passive on touch)
  let longHoverT=null;
  if (isFine){
  el.style.pointerEvents = 'auto';
  el.addEventListener('mouseenter', ()=>{
    el.classList.add('is-hover');
    longHoverT = setTimeout(()=> el.classList.add('is-longhover'), 1200);
  });
  el.addEventListener('mouseleave', ()=>{
    el.classList.remove('is-hover','is-active','is-longhover');
    if(longHoverT){ clearTimeout(longHoverT); longHoverT=null; }
  });
  el.addEventListener('mousedown', ()=> el.classList.add('is-active'));
  window.addEventListener('mouseup', ()=> el.classList.remove('is-active'));
} else {
  // Don’t force .style.pointerEvents = 'none' here — CSS will handle touch.
}


  // 5) rare micro-flicker for streetlight
  let flickerT=null;
  function scheduleFlicker(){
    if(flickerT){ clearTimeout(flickerT); flickerT=null; }
    if(el.getAttribute('data-kind')!=='streetlight') return;
    flickerT = setTimeout(()=>{
      el.classList.add('do-flicker');
      setTimeout(()=> el.classList.remove('do-flicker'), 180);
      scheduleFlicker();
    }, 12000 + Math.random()*6000);
  }

  // 6) cursor “typing heat”
  let typingT=null;
  function typingHeat(){
    if(el.getAttribute('data-kind')!=='cursor') return;
    el.classList.add('is-typing');
    clearTimeout(typingT);
    typingT = setTimeout(()=> el.classList.remove('is-typing'), 1400);
  }
  document.addEventListener('keydown', typingHeat, {passive:true});

  // 7) note “pluck” synced to your existing flash()
  function pulseNote(){
    if(el.getAttribute('data-kind')!=='note') return;
    el.classList.add('is-active','is-hover');
    setTimeout(()=>{ el.classList.remove('is-active'); el.classList.remove('is-hover'); }, 280);
  }
  if(typeof window.flash === 'function'){
    const _flash = window.flash;
    window.flash = function(){
      try{ pulseNote(); }catch(_){}
      return _flash.apply(this, arguments);
    };
  }

  // 8) tiny public API (handy for testing from the console)
  window.CB_SPRITE = {
    set: (k)=>render(k),   // e.g. CB_SPRITE.set('streetlight')
    show: ()=>{ el.style.display=''; },
    hide: ()=>{ el.style.display='none'; },
    pulse: pulseNote
  };

  // boot
  render(el.getAttribute('data-kind') || 'note');
})();

    /* ----------------------------
       UTILITIES
    ----------------------------- */
    const $ = sel => document.querySelector(sel);
    const screen = () => $('#cb-screen');
    const input  = () => $('#cb-input');
    const rootEl = () => $('#cb-console');
    const byId       = (a,b) => Number(a.id||0) - Number(b.id||0);
const byYearDesc = (a,b) => (Number(b.year||0) - Number(a.year||0)) ||
                            String(a.title||'').localeCompare(String(b.title||''));

    const pathEl = () => $('#cb-path');
    const STATE = {
  history: [], histIdx: -1,
  lastList: null, // remember last works listing for `back`
  linkMenu: null,   
  picker: null,
  turbo: false,
    contactPrompt: false,         // waiting for Enter on contact page
  contact: null,                // running wizard state (or null)

  asciiOn: true,
  theme: 'white',
    routingGuard: false,
  activeRoute: '',         // track current hash route
  skipNextRouteRender: false, // one-shot: when we render first, let router skip
  asciiCache: new Map(),     // key -> string (lines joined with \n)
  abortFlag: false,          // cooperative-cancel for printers
  runToken: null,             // hard-cancel token for current command
  pager: null
};

const LS = {
  get(k, def){ try{ const v = localStorage.getItem(k); return v ? JSON.parse(v) : def; } catch(_){ return def; } },
  set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); } catch(_){ } },
  del(k){ try{ localStorage.removeItem(k); } catch(_){ } }
};
const LS_KEYS = {
  history: 'cb.history.v1',
  theme:   'cb.theme.v1',
  route:   'cb.route.v1',
};
// === Blog config / cache keys ===
const BLOG_CFG = {
  owner: 'cbassuarez',
  repo: 'website-blog',
  branch: 'main',
  path: 'blog',
  apiList: (owner,repo,path,branch) =>
    `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`,
  rawBase: (owner,repo,branch) =>
    `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/`,
  ttlMs: 5*60*1000  // cache list for 5 minutes
};
const LS_BLOG = {
  index: 'cb.blog.index.v1'
};
// === Sounds config / cache keys ===
const SOUNDS_CFG = {
  owner: 'cbassuarez',
  repo: 'website-blog',
  branch: 'main', // pin to commit you provided
  path: 'audio',
  apiList: (owner,repo,path,branch) =>
    `https://api.github.com/repos/${owner}/${repo}/contents/${path}?ref=${branch}`,
  rawBase: (owner,repo,branch) =>
    `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/`,
  ttlMs: 5*60*1000
};
const LS_SOUNDS = { index: 'cb.sounds.index.v1' };


function pushRoute(hash){
  const target = hash.startsWith('#') ? hash : '#'+hash;
  if (location.hash !== target){
    // let hashchange drive rendering
    location.hash = target;
  } else {
    // same-route refresh (no hashchange will fire)
    STATE.forceRender = true;
    routeRender();
  }
}



// --- FIX: avoid duplicate renders (blog has its own router) ---
window.addEventListener('hashchange', () => {
  if (STATE.skipNextRouteRender){
    STATE.skipNextRouteRender = false;
    return;
  }
  const raw = (location.hash || '').replace(/^#/, '');
  if (/^(?:ls\/blog|blog|ls\/sounds|sounds)(?:$|\/|\?)/i.test(raw)) return; // blog & sounds own handlers
  if (STATE.routingGuard) return;
  routeRender();
});






// Generic pager
async function startPager({rows, pageSize=10, preface=[], onDone}){
  const tok = startRun(); // hard-cancel token for this pager run
  const pager = {rows, idx:0, pageSize, preface, prefacePrinted:false, onDone, tok};
  STATE.pager = pager;
  await pagerMore(pager);
}

function cancelPager(msg='(stopped)'){
  if (STATE.pager){ STATE.pager = null; println(msg, {fast:true}); }
}
function buildWorksHeader(list){
  const idW = Math.max(2, ...list.map(w => String(w.id||'').length));
  const header1 = `${'id'.padEnd(idW)}  year  type          slug              title`;
  const header2 = `${'-'.repeat(idW)}  ----  ------------  ----------------  -----`;
  return [header1, header2];
}

function buildWorksRows(list){
  const idW = Math.max(2, ...list.map(w => String(w.id||'').length));
  return list.map(w =>
    `${String(w.id).padStart(idW,'0')}  ${w.year}  ${String(w.type||'').padEnd(12)}  ${String(w.slug||'').padEnd(16)}  ${w.title||''}`
  );
}
// === Blog table header/rows (work-like) ===
function buildBlogHeader(list){
  const idW = Math.max(2, ...list.map(p => String(p.id||'').length));
  const header1 = `${'id'.padEnd(idW)}  date        type          slug              title`;
  const header2 = `${'-'.repeat(idW)}  ----------  ------------  ----------------  -----`;
  return [header1, header2];
}
function buildBlogRows(list){
  const idW = Math.max(2, ...list.map(p => String(p.id||'').length));
  return list.map(p =>
    `${String(p.id).padStart(idW,'0')}  ${(p.date||'').padEnd(10)}  ${String(p.type||'').padEnd(12)}  ${String(p.slug||'').padEnd(16)}  ${p.title||''}`
  );
}
async function renderBlogTags(){
  const posts = await buildBlogIndex({});
  const counts = new Map();
  posts.forEach(p => (p.tags||[]).forEach(t => counts.set(t, (counts.get(t)||0)+1)));

  const items = Array.from(counts.entries())
    .sort((a,b) => b[1]-a[1] || String(a[0]).localeCompare(String(b[0])));

  clearScreen();
  document.title = 'blog tags — seb suarez';
  setPathSuffix('blog/tags');

  if(!items.length){
    await println('(no tags yet)');
    await println('\nTip: add `tags:` to the first line of a post (see below).');
    return;
  }
  await println('tag                     count');
  await println('---------------------   -----');
  for(const [tag, n] of items){
    await println(String(tag).padEnd(21) + '   ' + String(n).padStart(3));
  }
  await println('\nFilter with: blog -g tags:<tag>');
}

// === Blog fetchers & parsers ===
function slugify(s){
  return String(s||'').toLowerCase()
    .replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
}
function hash16(s){ // stable-ish id from slug
  let h = 0;
  for(let i=0;i<s.length;i++){ h = (s.charCodeAt(i) + ((h<<6)+(h<<16) - h)) >>> 0; }
  return (h & 0xFFFF);
}
function parseFrontmatter(md){
  md = String(md||'').replace(/\r\n/g, '\n');
  if(!md.startsWith('---\n')) return {meta:{}, body:md};
  const end = md.indexOf('\n---', 4);
  if(end === -1) return {meta:{}, body:md};
  const fm = md.slice(4, end).trim();
  const body = md.slice(end+4).replace(/^\s+/, '');
  const meta = {};
  let lastKey = null;

  fm.split('\n').forEach(line=>{
    const kv = line.match(/^\s*([A-Za-z0-9_-]+)\s*:\s*(.*)$/);
    if(kv){
      lastKey = kv[1];
      let v = kv[2].trim();
      if(/^['"].*['"]$/.test(v)) v = v.slice(1,-1);
      // simple array support: tags: [a, b]
      if(v.startsWith('[') && v.endsWith(']')){
        v = v.slice(1,-1).split(',').map(x=>x.trim().replace(/^['"]|['"]$/g,'')).filter(Boolean);
      }
      meta[lastKey] = v;
    } else if (/^\s*-\s+/.test(line) && lastKey){
      // list continuation: tags:
      const arr = Array.isArray(meta[lastKey]) ? meta[lastKey] : [];
      arr.push(line.replace(/^\s*-\s+/, '').trim());
      meta[lastKey] = arr;
    }
  });
  return {meta, body};
}

// === Sounds table header/rows (work/blog-like) ===
function buildSoundsHeader(list){
  const idW = Math.max(2, ...list.map(p => String(p.id||'').length));
  const header1 = `${'id'.padEnd(idW)}  engine  slug              title`;
  const header2 = `${'-'.repeat(idW)}  ------  ----------------  -----`;
  return [header1, header2];
}
function buildSoundsRows(list){
  const idW = Math.max(2, ...list.map(p => String(p.id||'').length));
  return list.map(p =>
    `${String(p.id).padStart(idW,'0')}  ${String(p.engine||'').padEnd(6)}  ${String(p.slug||'').padEnd(16)}  ${p.title||''}`
  );
}

// === Sounds index (GitHub folder listing → records) ===
function soundsCacheGet(){
  const hit = LS.get(LS_SOUNDS.index, null);
  if (!hit) return null;
  if (Date.now() - (hit.t||0) > SOUNDS_CFG.ttlMs) return null;
  return hit.items || null;
}
function soundsCacheSet(items){
  try { LS.set(LS_SOUNDS.index, {t:Date.now(), items}); } catch(_){}
}

async function githubListSounds(){
  const url = SOUNDS_CFG.apiList(SOUNDS_CFG.owner, SOUNDS_CFG.repo, SOUNDS_CFG.path, SOUNDS_CFG.branch);
  const r = await fetch(url, {headers:{'Accept':'application/vnd.github+json'}});
  if (!r.ok) throw new Error('sounds list fetch failed');
  return await r.json();
}

function rawJoinSounds(suffix=''){
  return SOUNDS_CFG.rawBase(SOUNDS_CFG.owner, SOUNDS_CFG.repo, SOUNDS_CFG.branch) + String(suffix||'').replace(/^\/+/,'');
}
function cdnJoinSounds(path=''){
  const p = String(path||'').replace(/^\/+/,'');
  // Load from jsDelivr so we can import the module directly with the right MIME type
  return `https://cdn.jsdelivr.net/gh/${SOUNDS_CFG.owner}/${SOUNDS_CFG.repo}@${SOUNDS_CFG.branch}/${p}`;
}
function bust(url){
  const sep = url.includes('?') ? '&' : '?';
  return url + sep + 'v=' + Date.now(); // force a fresh fetch every run
}
/** Detect engine by file extension (engine can be overridden by inline meta) */
function inferEngineFromPath(name){
  const n = String(name||'').toLowerCase();
  if (n.endsWith('.ck')) return 'chuck';
  if (n.endsWith('.mjs') || n.endsWith('.js')) return 'tone';
  return '';
}

function parseInlineMetaFromCode(txt){
  // very lightweight: scan first 1–3 non-empty comment lines for key: value
  const out = {};
  const lines = String(txt||'').split(/\r?\n/).slice(0, 5);
  const rx = /^\s*(?:\/\/|#|\/\*)?\s*([a-zA-Z0-9_-]+)\s*:\s*(.+?)\s*(?:\*\/)?\s*$/;
  for (const ln of lines){
    const m = rx.exec(ln);
    if (m){ out[m[1].toLowerCase()] = m[2].trim(); }
  }
  return out;
}

async function buildSoundsIndex({ refresh=false } = {}){
  if (!refresh){
    const cached = soundsCacheGet();
    if (cached) return cached;
  }
  const listing = await githubListSounds();

  // only files we know how to run
  const files = listing.filter(x => x.type === 'file' && inferEngineFromPath(x.name));

  // fetch a tiny bit of each to pull optional metadata (title, tags, engine)
  const items = [];
  let id = 1;
  for (const f of files){
    const engine = inferEngineFromPath(f.name);
    const slug = f.name.replace(/\.(ck|mjs|js)$/i,'');
    let title = slug.replace(/[-_]+/g,' ');

    // read just enough for optional inline meta
    let meta = {};
    try {
      const url = f.download_url || rawJoinSounds(f.path || `${SOUNDS_CFG.path}/${f.name}`);
      const txt = await fetch(url, {method:'GET'}).then(r => r.ok ? r.text() : '');
      meta = parseInlineMetaFromCode(txt);
      if (meta.title) title = meta.title;
    } catch(_){}

    const rec = {
      id: id++,
      engine: (meta.engine || engine || '').toLowerCase(),
      slug,
      title,
      path: f.path || `${SOUNDS_CFG.path}/${f.name}`,
      download_url: f.download_url || rawJoinSounds(f.path || `${SOUNDS_CFG.path}/${f.name}`)
    };
    items.push(rec);
  }

  // sort stable by slug (or title); tiny list
  items.sort((a,b)=> String(a.slug).localeCompare(String(b.slug)));
  soundsCacheSet(items);
  return items;
}
// --- page title helper (matches 'about — seb suarez') ---
const SITE_NAME = 'seb suarez';
function setDocTitle(label=''){
  document.title = label ? `${label} — ${SITE_NAME}` : SITE_NAME;
}

// === Sounds list renderer ===


async function renderSoundsList(flags=[]){
  const refresh = flags.includes('--refresh') || flags.includes('-r');
  let list = await buildSoundsIndex({ refresh });

  // basic filters: sounds -g engine:<tone|chuck>
  const gi = flags.indexOf('-g');
  if (gi>-1 && flags[gi+1]){
    const [k,vRaw] = String(flags[gi+1]).split(':',2);
    if (k && vRaw){
      const v = vRaw.toLowerCase();
      if (k==='engine') list = list.filter(p => String(p.engine||'').toLowerCase().includes(v));
      if (k==='slug')   list = list.filter(p => String(p.slug||'').toLowerCase().includes(v));
      if (k==='title')  list = list.filter(p => String(p.title||'').toLowerCase().includes(v));
    }
  }

  clearScreen();
setDocTitle('sounds');
  setPathSuffix('sounds');

  const header = buildSoundsHeader(list);
  const rows   = buildSoundsRows(list);

  // If called from CLI (not hash), push a shareable hash
  {
    const raw = (location.hash || '').replace(/^#/, '');
    const alreadyOnList = /^(?:ls\/sounds|sounds)(?:$|\?)/i.test(raw);
    if (!alreadyOnList) {
      const q = [];
      if (refresh) q.push('refresh=1');
      if (gi>-1 && flags[gi+1]) q.push('g='+encodeURIComponent(flags[gi+1]));
      pushRoute('ls/sounds' + (q.length?('?'+q.join('&')):''));
    }
  }

  await startPager({
    preface: header,
    rows,
    pageSize: 10,
    onDone: async () => {
      await println('\nCommands: [ play <id|slug> ] [ stop <ns|all> ] [ back ]', {nowrap:true});
    }
  });
  Sprite.on();
}
async function update(ns, patch){
  try{
    const rec = running.get(ns);
    if (!rec) return false;

    // 1) Preferred: live update on the controller
    const ctl = rec.controller;
    if (ctl && typeof ctl.update === 'function'){
      const r = await ctl.update(patch || {});
      if (r !== false) {
        // keep params in sync for future restarts
        rec.params = Object.assign({}, rec.params || {}, patch || {});
        return true;
      }
    }

    // 2) Fallback: hot-restart with merged params (always works)
    if (!rec.item) return false;                       // need the module record
    const merged = Object.assign({}, rec.params || {}, patch || {});
    await stop(ns);
    await run(rec.item, { ns, params: merged });
    return true;
  } catch(_){
    return false;
  }
}

// alias
const set = update;


// --- Inline meta (first line) ----------------------------------------------
// Recognized keys: date, type, slug, tags, title
function isInlineMetaLine(s){
  if(!s) return false;
  // must contain at least one recognized key followed by : or =
  return /(^(?:\s*)?(date|type|slug|tags|title)\s*[:=]\s*)/i.test(s);
}
function parseInlineMetaFromBody(body){
  const out = { meta:{}, body: body || '', consumedFirstLine:false };
  const lines = String(body||'').replace(/\r\n/g,'\n').split('\n');
  let i = 0; while(i<lines.length && !lines[i].trim()) i++;   // first non-empty
  if(i >= lines.length) return out;

  const first = lines[i].trim();
  if(!isInlineMetaLine(first)) return out;

  // Extract "key: value" or "key=value" pairs delimited by | ; or end-of-line
  const meta = {};
  const re = /\b(date|type|slug|tags|title)\s*[:=]\s*([^|;]+?)(?=\s*(?:\||;|$))/gi;
  let m; 
  while((m = re.exec(first)) !== null){
    const k = m[1].toLowerCase();
    let v = (m[2] || '').trim();
    // tags: [a, b] | a, b | a|b
    if(k === 'tags'){
      if(v.startsWith('[') && v.endsWith(']')) v = v.slice(1, -1);
      meta.tags = v.split(/\s*,\s*|\s*\|\s*|\s*;\s*/).map(x=>x.trim()).filter(Boolean);
    } else {
      meta[k] = v;
    }
  }

  // Remove the meta line from body when it actually had pairs
  if(Object.keys(meta).length){
    lines.splice(i, 1);
    out.consumedFirstLine = true;
    out.meta = meta;
    out.body = lines.join('\n').replace(/^\s+/, '');
  }
  return out;
}

// --- Setext sections (H2-style "Title" + "-----" line) --------------------
function parseSetextSections(md) {
  const lines = String(md||'').replace(/\r\n/g,'\n').split('\n');

  // a "setext H2" is "text" followed by a line of 4+ dashes.
  const isH2Underline = s => /^-{4,}\s*$/.test(s);          // avoid HR '---'
  const isHeadingLine = s => !!s && !/^\s*$/.test(s);

  const sections = [];
  let i = 0;
  while (i < lines.length) {
    // find "title" followed by dash underline
    if (isHeadingLine(lines[i]) && (i+1) < lines.length && isH2Underline(lines[i+1])) {
      const title = lines[i].trim();
      i += 2; // skip title + underline
      const body = [];
      // collect until next heading or EOF
      while (i < lines.length && !(isHeadingLine(lines[i]) && (i+1) < lines.length && isH2Underline(lines[i+1]))) {
        body.push(lines[i++]);
      }
      sections.push({ title, body: body.join('\n') });
    } else {
      // skip non-section text (preamble)
      i++;
    }
  }
  return sections;
}

// Normalize a selector ('a', '1', 'Some Title') to a section index
function selectSectionIndex(sel, sections) {
  if (!sel) return -1;
  const s = String(sel).trim().toLowerCase();
  // a/b/c…
  if (/^[a-z]$/.test(s)) {
    const idx = s.charCodeAt(0) - 97; // 'a' -> 0
    return (idx >= 0 && idx < sections.length) ? idx : -1;
  }
  // 1-based number
  if (/^\d+$/.test(s)) {
    const n = parseInt(s, 10);
    return (n >= 1 && n <= sections.length) ? (n-1) : -1;
  }
  // title prefix/substring
  let hit = sections.findIndex(x => (x.title||'').toLowerCase().startsWith(s));
  if (hit === -1) hit = sections.findIndex(x => (x.title||'').toLowerCase().includes(s));
  return hit;
}

// Store interactive post state here
STATE.blogPost = null; // {slug,title,mdFilePath,sections,open:Set<number>}

function sectionKey(i){ return String.fromCharCode(97 + i); } // a/b/…

async function renderSectionsMenu() {
  const ctx = STATE.blogPost;
  if (!ctx) return;
  await println('> SECTIONS', {fast:true});
  for (let i=0; i<ctx.sections.length; i++){
    const s = ctx.sections[i];
    const mark = ctx.open.has(i) ? '▾' : '▸';
    await println(`${mark} ${sectionKey(i)}) ${s.title}`);
  }
  await println('\nCommands: [ toggle <a|1|title> ]  [ expand all ]  [ collapse all ]  [ sections ]  [ back ]',
                {fast:true, nowrap:true});
}





function isoDateOnly(s){
  if(!s) return '';
  const t = String(s).trim();

  // 1) native
  let d = new Date(t);
  if(!isNaN(d)) {
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd= String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }

  // 2) YYYY/MM/DD or YYYY-MM-DD or YYYY.MM.DD
  let m = t.match(/^(\d{4})[\/\-.](\d{1,2})[\/\-.](\d{1,2})$/);
  if(m){
    const y = +m[1], mo = String(+m[2]).padStart(2,'0'), da = String(+m[3]).padStart(2,'0');
    return `${y}-${mo}-${da}`;
  }

  // 3) MM/DD/YYYY
  m = t.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{4})$/);
  if(m){
    const y = +m[3], mo = String(+m[1]).padStart(2,'0'), da = String(+m[2]).padStart(2,'0');
    return `${y}-${mo}-${da}`;
  }

  // 4) "Apr 8 2025" / "April 8, 2025"
  m = t.match(/^([A-Za-z]{3,})\s+(\d{1,2}),?\s+(\d{4})$/);
  if(m){
    const months = {
      jan:1,feb:2,mar:3,apr:4,may:5,jun:6,
      jul:7,aug:8,sep:9,oct:10,nov:11,dec:12
    };
    const mo = months[m[1].slice(0,3).toLowerCase()] || 1;
    const y = +m[3], da = String(+m[2]).padStart(2,'0');
    return `${y}-${String(mo).padStart(2,'0')}-${da}`;
  }

  return ''; // unknown format → leave blank
}


async function githubListFolder(){
  const url = BLOG_CFG.apiList(BLOG_CFG.owner, BLOG_CFG.repo, BLOG_CFG.path, BLOG_CFG.branch);
  const res = await fetch(url, {mode:'cors', credentials:'omit', headers:{'Accept':'application/vnd.github+json'}});
  if(!res.ok) throw new Error(`GitHub: HTTP ${res.status}`);
  return await res.json(); // array of {name, path, download_url, type}
}
async function fetchText(u){
  const r = await fetch(u, {mode:'cors', credentials:'omit'});
  if(!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.text();
}

function blogCacheGet(){
  try{
    const raw = localStorage.getItem(LS_BLOG.index);
    if(!raw) return null;
    const j = JSON.parse(raw);
    if(!j || !j.ts || !Array.isArray(j.items)) return null;
    if (Date.now() - j.ts > BLOG_CFG.ttlMs) return null;
    return j.items;
  }catch(_){ return null; }
}
function blogCacheSet(items){
  try{ localStorage.setItem(LS_BLOG.index, JSON.stringify({ts:Date.now(), items})); }catch(_){}
}

function rawJoin(...parts){
  return BLOG_CFG.rawBase(BLOG_CFG.owner, BLOG_CFG.repo, BLOG_CFG.branch) + parts.map(p=>String(p).replace(/^\/+|\/+$/g,'')).join('/');
}
function resolveAssetUrl(mdFilePath, assetHref){
  if(/^https?:\/\//i.test(assetHref)) return assetHref;
  // relative to the md file directory under repo root
  const dir = mdFilePath.replace(/\/[^\/]+$/, '/');
  return rawJoin(dir, assetHref);
}

async function buildBlogIndex({force=false}={}){
  // try cache (same as before)
  let posts = null;
  if(!force){
    const cached = blogCacheGet();
    if(cached) posts = cached;
  }

  if(!posts){
    const list = await githubListFolder();
    const mdfiles = list.filter(x => x.type === 'file' && /\.mdx?$/i.test(x.name));

    posts = [];
    for (const file of mdfiles){
      const md = await fetchText(file.download_url);
      const {meta, body} = parseFrontmatter(md);
      const inline = parseInlineMetaFromBody(body);
      const merged = Object.assign({}, meta, inline.meta);

      const title = merged.title || file.name.replace(/\.(md|mdx)$/i,'');
      const slug  = merged.slug ? slugify(merged.slug) : slugify(title);
      const type  = merged.type || 'post';
      const date  = isoDateOnly(merged.date || '');
      const tags  = Array.isArray(merged.tags) ? merged.tags : (merged.tags ? [merged.tags] : []);

      posts.push({
        // NOTE: no hash-based id anymore
        slug, title, type, date, tags,
        path: file.path,
        download_url: file.download_url,
        _body: inline.body,
        _inlineMeta: inline.consumedFirstLine
      });
    }
  }

  // sort newest first (same policy you had)
  posts.sort((a,b)=> (b.date||'').localeCompare(a.date||'') ||
                     String(a.title).localeCompare(String(b.title)));

  // --- SEQUENTIALIZE IDs (1..N) every build, including cached loads ---
  posts.forEach((p, idx) => { p.id = idx + 1; });

  blogCacheSet(posts);
  return posts;
}


async function sendContact(payload){
  const cfg = DATA.meta?.form || {};
  const url = cfg.endpoint;
  if (!url) throw new Error('No form endpoint configured');

  // build body in two encodings (JSON or classic form)
  const useJson = String(cfg.method||'json').toLowerCase() === 'json';
  let opts;
  if (useJson){
    opts = {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'Accept':'application/json' },
      body: JSON.stringify(payload),
      mode:'cors', credentials:'omit'
    };
  } else {
    const params = new URLSearchParams();
    Object.entries(payload).forEach(([k,v])=> params.append(k, v==null?'':String(v)));
    opts = {
      method:'POST',
      headers:{ 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8',
                'Accept':'application/json, text/plain, */*' },
      body: params.toString(),
      mode:'cors', credentials:'omit'
    };
  }

  const res = await fetch(url, opts);
  if (!res.ok){
    let t = '';
    try{ t = (await res.text()).slice(0,250); }catch(_){}
    throw new Error(`HTTP ${res.status}${t ? ` — ${t}` : ''}`);
  }
  // if the service returns JSON with an error field, surface it
  try{
    const ct = res.headers.get('content-type')||'';
    if (ct.includes('json')){
      const j = await res.json();
      if (j && (j.ok===false || j.error)) throw new Error(j.error || 'Send rejected');
    }
  }catch(_){}
  
}


async function pagerMore(p = STATE.pager){
  if (!p) return;
  const bail = () => (!STATE.pager || STATE.pager !== p || isCancelled(p.tok));

  // print preface once
  if (!p.prefacePrinted && p.preface?.length){
    for (const line of p.preface){
      if (bail()) return;
      await println(line);
      if (bail()) return;
    }
    p.prefacePrinted = true;
  }

  // print next page
  const end = Math.min(p.idx + p.pageSize, p.rows.length);
  for (let i = p.idx; i < end; i++){
    if (bail()) return;
    await println(p.rows[i]);
    if (bail()) return;
  }
  if (bail()) return;

  p.idx = end;

  if (p.idx >= p.rows.length){
    if (STATE.pager === p) STATE.pager = null;
    if (typeof p.onDone === 'function') await p.onDone();
  } else {
    const remain = p.rows.length - p.idx;
    if (bail()) return;
    await println(
      `(press Enter for next ${Math.min(p.pageSize, remain)}; ${remain} remaining; type q or press Ctrl+C to stop)`,
      {fast:true}
    );
  }
}


function showCommandsOverlay(text){
  const el = $('#cb-commands');
  if(!el) return;
  if(text){
    el.textContent = text;
    el.style.display = 'block';
  } else {
    el.textContent = '';
    el.style.display = 'none';
  }
}

function formatBytes(n){
  if(!Number.isFinite(n) || n<=0) return '0 B';
  const u = ['B','KB','MB','GB','TB']; let i=0;
  while(n>=1024 && i<u.length-1){ n/=1024; i++; }
  return n.toFixed(n<10 && i>0 ? 1 : 0) + ' ' + u[i];
}
function formatETA(ms){
  if(!Number.isFinite(ms) || ms<=0) return '—';
  const s = Math.ceil(ms/1000);
  const m = Math.floor(s/60), r = s%60;
  return (m? (String(m).padStart(2,'0') + ':') : '') + String(r).padStart(2,'0');
}
function makeProgressLine(label){
  const el = document.createElement('div');
  el.className = 'line dim';
  el.textContent = label;
  screen().appendChild(el);
  screen().scrollTop = screen().scrollHeight;
  return el;
}
function renderProgress(el, {done=0, total=0, speed=0, eta=0, label=''}){
  const width = Math.max(20, Math.min(40, Math.floor((screen().clientWidth || 640)/24)));
  const pct = total ? Math.min(1, done/total) : 0;
  const fill = Math.round(pct*width);
  const bar = '[' + '#'.repeat(fill) + '-'.repeat(width-fill) + ']';
  const left = total ? `${(pct*100).toFixed(1)}%` : formatBytes(done);
  const spd  = speed ? `${formatBytes(speed)}/s` : '';
  const etaS = total ? `ETA ${formatETA(eta)}` : '';
  el.textContent = `${label}  ${bar}  ${left}${total?' of '+formatBytes(total):''}  ${spd}  ${etaS}`;
  screen().scrollTop = screen().scrollHeight;
}
function saveBlob(blob, filename){
  const a = document.createElement('a');
  const href = URL.createObjectURL(blob);
  a.href = href; a.download = filename; a.rel='noopener';
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(href); a.remove(); }, 0);
}
// --- NEW: ATX section parser (# H1 intro, then ## sections) -----------------
// ATX-only: # title (intro follows) and ## sections
function parseAtxSections(md){
  const src = String(md||'').replace(/\r\n/g, '\n');
  const lines = src.split('\n');

  // 0) strip leading blanks
  while (lines.length && !lines[0].trim()) lines.shift();

  // 1) drop a single inline-meta line if present
  if (lines[0] && isInlineMetaLine(lines[0].trim())) {
    lines.shift();
    while (lines.length && !lines[0].trim()) lines.shift();
  }

  // 2) H1 title (optional but recommended)
  let title = '';
  let i = 0;
  if (/^#\s+/.test(lines[0]||'')) {
    title = lines[0].replace(/^#\s+/, '').trim();
    i = 1;
  }

  // 3) collect all H2 starts
  const h2 = [];
  for (let j=i; j<lines.length; j++){
    if (/^##\s+/.test(lines[j])) h2.push(j);
  }

  // 4) intro = everything from after H1 to the first H2 (or EOF)
  const intro = lines.slice(i, h2.length ? h2[0] : lines.length).join('\n').trim();

  // 5) sections = chunks between consecutive H2s
  const sections = [];
  for (let k=0; k<h2.length; k++){
    const start = h2[k];
    const end   = (k+1<h2.length) ? h2[k+1] : lines.length;
    const heading = lines[start].replace(/^##\s+/, '').trim();
    const body    = lines.slice(start+1, end).join('\n').trim();
    sections.push({ title: heading, body });
  }

  return { title, intro, sections };
}

// Unified: ATX only (no setext fallback) + keeps file path for images
function sectionizePost(md, { mdFilePath='' } = {}){
  const { title, intro, sections } = parseAtxSections(md);
  return { title, intro, sections, mdFilePath };
}


// --- UPDATED: menu printer (unchanged API; just names are a/b/1/title) -----
async function renderSectionsMenu(){
  const ctx = STATE.blogPost;
  if (!ctx) return;

  await println('> SECTIONS', {fast:true});
  for (let i=0; i<ctx.sections.length; i++){
    const s = ctx.sections[i];
    const mark = ctx.open.has(i) ? '▾' : '▸';
    const key  = String.fromCharCode(97 + i); // a/b/…
    await println(`${mark} ${key}) ${s.title}`);
  }
  await println(
    '\nCommands: [ toggle <a|1|title> ]  [ expand all ]  [ collapse all ]  [ sections ]  [ back ]',
    {fast:true, nowrap:true}
  );
}

async function buildBlogPostContext({ slug, title, md, mdFilePath }){
  const parsed = sectionizePost(md, { mdFilePath });

  // prefer parsed H1 if present
  const finalTitle = (parsed.title || title || slug || '').trim() || 'Post';

  // accept both ?long=1 and ?l=1
  const isLong = /[?&](?:long|l)=1\b/i.test(location.hash);

  const open = new Set();
  if (isLong) for (let i=0;i<(parsed.sections||[]).length;i++) open.add(i);

  STATE.blogPost = {
    slug,
    title: finalTitle,
    mdFilePath: parsed.mdFilePath,
    intro: parsed.intro || '',
    sections: parsed.sections || [],
    open
  };
}


// --- HELPERS: select by a/b/1/title ---------------------------------------
function selectSectionIndex(sel, sections){
  if (!sel) return -1;
  const s = String(sel).trim().toLowerCase();
  if (/^[a-z]$/.test(s)){
    const idx = s.charCodeAt(0) - 97;
    return (idx>=0 && idx<sections.length) ? idx : -1;
  }
  if (/^\d+$/.test(s)){
    const n = parseInt(s,10);
    return (n>=1 && n<=sections.length) ? (n-1) : -1;
  }
  let hit = sections.findIndex(x => (x.title||'').toLowerCase().startsWith(s));
  if (hit === -1) hit = sections.findIndex(x => (x.title||'').toLowerCase().includes(s));
  return hit;
}



/* -------- Bell + visual flash (no assets) -------- */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function flash(){
  const el = rootEl();
  el.classList.add('cb-flash');
  setTimeout(()=> el.classList.remove('cb-flash'), 140);
}
/* ---- Cancel helpers ---- */
function echoInstant(line){
  const el = document.createElement('div');
  el.className = 'line';
  el.textContent = line;
  screen().appendChild(el);
  const sc = screen(); sc.scrollTop = sc.scrollHeight;
}
// 1) Upgrade ctrlCancel to cancel pager, too
function ctrlCancel(){
  cancelRun();                 // flips run token + sets abortFlag
  cancelPager('(stopped)');    // drops STATE.pager immediately
  FastHint.end();
  echoInstant('^C');
  flash(); 
  promptFocus();
}

function hasSelection(){ const s = window.getSelection?.(); return s && !s.isCollapsed; }

function handleCtrlC(e){
  const isCtrlC = (e.ctrlKey || e.metaKey) && (e.key || '').toLowerCase() === 'c';
  if (!isCtrlC) return;
  if (e.metaKey && hasSelection()) return; // don't steal ⌘C copy

  if (STATE.pager){
    e.preventDefault(); e.stopPropagation();
    ctrlCancel();
  }
}

// rebind Ctrl+C cleanly (prevents duplicates if this code runs twice)
window.removeEventListener('keydown', handleCtrlC, true);
input().removeEventListener('keydown', handleCtrlC, true);
window.addEventListener('keydown', handleCtrlC, true);
input().addEventListener('keydown', handleCtrlC, true);


// === SoundEngines: run Tone.js or WebChucK patches ===
const SoundEngines = (() => {
  const running = new Map(); // ns -> {engine, stopper, item}
  let toneReady = null;
  let chuckReady = null;

  function loadScriptOnce(src, globalKey){
    return new Promise((resolve, reject) => {
      if (globalKey && window[globalKey]) return resolve();
      const s = document.createElement('script');
      s.src = src; s.async = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
      s.onload = () => resolve();
      s.onerror = () => reject(new Error('script load failed: '+src));
      document.head.appendChild(s);
    });
  }
async function unlock(ToneLib){
  const Ctx = window.AudioContext || window.webkitAudioContext;
  // Prefer Tone’s context if present; otherwise use a shared ctx
  let ctx = (ToneLib && ToneLib.getContext && ToneLib.getContext().rawContext) || window.__cbAudioCtx;
  if (!ctx) { ctx = new Ctx(); window.__cbAudioCtx = ctx; }

  try { if (ctx.state !== 'running') await ctx.resume(); } catch(_){}
  // tiny silent node to tick the graph on iOS/Safari
  try{
    const src = ctx.createBufferSource();
    src.buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
    src.connect(ctx.destination);
    src.start(0);
  } catch(_){}
  return ctx;
}

  async function ensureTone(){
    if (window.Tone) return window.Tone;
    if (!toneReady){
      // pinned major; feel free to bump later
      toneReady = loadScriptOnce('https://cdn.jsdelivr.net/npm/tone@14/build/Tone.js','Tone').then(()=>window.Tone);
    }
    return await toneReady;
  }

  // keep this where your other lazy loaders live
// ESM loader for WebChucK (no globals)
async function ensureWebChucK() {
  if (!window.__webchuckModule) {
    window.__webchuckModule = await import('https://cdn.jsdelivr.net/npm/webchuck@1.2.10/+esm');
  }
  return window.__webchuckModule; // { Chuck, ... }
}

// Always return a REAL BaseAudioContext (not a Tone wrapper)
function getBaseAudioContext() {
  const AC = window.AudioContext || window.webkitAudioContext;
  // try to unwrap Tone first
  try {
    const toneCtx = (window.Tone?.getContext?.()) || window.Tone?.context || null;
    if (toneCtx?.rawContext instanceof AC) {
      window.__cbAudioCtx = toneCtx.rawContext;
      return window.__cbAudioCtx;
    }
  } catch (_) {}

  // reuse a cached real context if we made one before
  if (window.__cbAudioCtx instanceof AC) return window.__cbAudioCtx;

  // last resort: make a fresh real context
  window.__cbAudioCtx = new AC();
  return window.__cbAudioCtx;
}



  function pickNs(base='s'){
    let i = 1;
    while (running.has(base+i)) i++;
    return base+i;
  }

  async function run(item, {ns, params={}}={}){
    const engine = String(item.engine||'').toLowerCase();
    if (!ns) ns = pickNs('s');

    if (engine === 'tone'){
   const Tone = await ensureTone();
  try { await Tone.start?.(); } catch(_) {}
  const ctx = await unlock(Tone);
  // make sure the clock is actually running
  try {
    if (Tone.Transport.state !== 'started') {
      Tone.Transport.start('+0.02'); // kick after a tick
    }
    // just in case a global mute snuck in
    Tone.Destination.mute = false;
  } catch(_) {}

  // per-run bus we control
  const bus = new Tone.Gain(1).toDestination();

  // import the ES module properly
  // Always fetch fresh code from download_url and import via blob
const code = await fetch(item.download_url, { cache: 'no-store' })
  .then(r => r.ok ? r.text() : Promise.reject('fetch failed'));

const blob = new Blob([code], { type: 'text/javascript' });
const url  = URL.createObjectURL(blob);
let mod;
try {
  mod = await import(/* webpackIgnore: true */ url);
} finally {
  URL.revokeObjectURL(url);
}
const starter = mod?.default || mod?.start || mod?.run;
if (typeof starter !== 'function') throw new Error('module did not export start/default');

// call the patch — MUST return a function we keep as the controller
const controller = await starter({ Tone, context: ctx, params, out: bus }) || (()=>{});

// stopper calls the controller (teardown) and fades the bus
const stopper = async () => {
  try { await controller(); } catch(_){}
  try { bus.gain.rampTo(0, 0.05); } catch(_){}
  try { bus.dispose(); } catch(_){}
};

// store controller so `set` can live-update
// TONE branch – after you build `controller` and `stopper`
running.set(ns, { engine:'tone', stopper, controller, item, params, bus });

return { ns };



}


   if (engine === 'chuck'){
  const { Chuck } = await ensureWebChucK();

  // 1) ALWAYS a real BaseAudioContext
  const ctx = getBaseAudioContext();
  try { if (ctx.state !== 'running') await ctx.resume(); } catch {}

  // 2) per-run bus (native node) so you can meter/stop
  const bus = ctx.createGain();
  bus.gain.value = 1.0;
  bus.connect(ctx.destination);

  // 3) init ChucK on THIS exact context and route to bus
  let chuckVM;
  try {
    chuckVM = await Chuck.init([], ctx);
  } catch (e) {
    // If a legacy path somehow still passed a wrapper, hard-fallback to a fresh real context:
    const AC = window.AudioContext || window.webkitAudioContext;
    const fresh = new AC();
    await fresh.resume?.();
    chuckVM = await Chuck.init([], fresh);
    // route straight to its own destination if cross-context
    try { chuckVM.connect(fresh.destination); } catch {}
  }
  try { chuckVM.connect(bus); } catch {} // no-op if we fell back to a separate context

  // 4) fetch and run .ck
  const code = await fetch(item.download_url, { cache: 'no-store' }).then(r => r.text());
  await chuckVM.runCode(code);

  // 5) stopper
  const stopper = async () => {
    try { await chuckVM.clearChuckInstance?.(); } catch {}
    try {
      const t = ctx.currentTime || 0;
      bus.gain.cancelScheduledValues(t);
      bus.gain.setValueAtTime(bus.gain.value, t);
      bus.gain.linearRampToValueAtTime(0, t + 0.06);
    } catch {}
    try { chuckVM.disconnect?.(); } catch {}
    try { bus.disconnect(); } catch {}
  };

// CHUCK branch – after `stopper` is defined
running.set(ns, {
  engine:'chuck',
  item,
  bus,
  stopper,
  params         // ⬅️ keep last-known params for hot-restart
});
return { ns };
}


    throw new Error('unknown engine: ' + engine);
  }

  function stop(target=''){
  const kill = async (key) => {
    const r = running.get(key);
    if (!r) return;
    try { await r.stopper?.(); } catch(_){}
    // extra failsafe: if a bus exists, zero and dispose
    try {
      if (r.bus && r.bus.gain && typeof r.bus.gain.rampTo === 'function') r.bus.gain.rampTo(0, 0.05);
      if (r.bus && typeof r.bus.dispose === 'function') r.bus.dispose();
    } catch(_){}
    running.delete(key);
  };

  if (target === 'all'){
    const keys = Array.from(running.keys());
    keys.forEach(k => kill(k));
    return { stopped:'all' };
  }
  if (!target){
    const first = running.keys().next();
    if (!first.done){ kill(first.value); return { stopped:first.value }; }
    return { stopped:null };
  }
  if (running.has(target)){ kill(target); return { stopped:target }; }
  return { stopped:null };
}
async function update(ns, patch){
  // broadcast support
  if (String(ns).toLowerCase() === 'all'){
    let ok = 0, fail = 0;
    for (const [key] of running) {
      (await update(key, patch)) ? ok++ : fail++;
    }
    return ok > 0;
  }

  const rec = running.get(ns);
  if (!rec) return false;

  // 1) Preferred: live controller.update(patch)
  const ctl = rec.controller;
  if (ctl && typeof ctl.update === 'function'){
    try { await ctl.update(patch || {}); return true; }
    catch (_) { /* fall through to hot-restart */ }
  }

  // 2) Fallback: HOT-RESTART with merged params (lossless, quick)
  try {
    const merged = Object.assign({}, rec.params || {}, patch || {});
    // stop current run
    try { await rec.stopper?.(); } catch(_){}
    running.delete(ns);

    // re-run the same item with same ns + merged params
    await run(rec.item, { ns, params: merged });
    return true;
  } catch (_){
    return false;
  }
}

// alias
function list(){
  return Array.from(running.entries()).map(([ns, r]) => ({
    ns,
    engine: r.engine,
    slug:   r.item?.slug || '',
    controller: r.controller,
    item:   r.item || null,
    params: r.params || {},
    bus:    r.bus
  }));
}


return { run, stop, list, unlock, update, set };


})();
window.SoundEngines = SoundEngines;

// ───────────────────────────────────────────────────────────────────────────────
// Split Manager (two-pane UI inside #cb-screen; ASCII style; 60/40; meters)
// ───────────────────────────────────────────────────────────────────────────────
(() => {
  const MIN_COL = 20; // min characters for each pane
  const MOBILE_MIN_PX = 820; // disable split under this width
  const LS_KEY = 'cb_split_state_v1';
  const E = Object.assign;

  // state
  const state = {
    open: false,
    ratio: 0.6, // left %
    focus: 'left', // 'left'|'right'
    persist: true,
    mode: 'sounds', // which page opened it (for future)
    followNs: null, // mixed feed by default
    filter: '',
  };

  // els
  let root, left, right, style;

  // helpers
  function lsLoad(){
    try {
      const s = JSON.parse(localStorage.getItem(LS_KEY)||'{}');
      if (typeof s.ratio === 'number') state.ratio = s.ratio;
      if (typeof s.focus === 'string') state.focus = s.focus;
    } catch(_) {}
  }
  function lsSave(){
    if (!state.persist) return;
    try {
      localStorage.setItem(LS_KEY, JSON.stringify({ ratio: state.ratio, focus: state.focus }));
    } catch(_) {}
  }
  function mm(val, lo, hi){ return Math.max(lo, Math.min(hi, val)); }
  function rowsCols(){
    const pre = document.querySelector('#cb-screen');
    const w = pre?.clientWidth || 1000;
    const h = pre?.clientHeight || 600;
    const ch = parseFloat(getComputedStyle(pre).lineHeight) || 18;
    const cw = 8; // monospace approx
    return { rows: Math.floor(h / ch), cols: Math.floor(w / cw) };
  }
  function headerLine(title, width){
    const name = ` ${title} `;
    const dashes = Math.max(0, width - name.length - 2);
    return `|${name}${'-'.repeat(dashes)}|\n`;
  }
  function horizRule(width){ return `+${'-'.repeat(width-2)}+\n`; }

  function ensureDom(){
    if (root && root.isConnected) return;
    const screen = document.querySelector('#cb-screen');
    if (!screen) return;

    // container with two <pre> that scroll independently
    root = document.createElement('div');
    root.id = 'cb-split';
    root.innerHTML = `
      <div class="cb-split-left"><pre class="cb-left-pre" aria-label="left"></pre></div>
      <div class="cb-split-right"><pre class="cb-right-pre" aria-label="right"></pre></div>
    `;
    // inject CSS (ASCII borders; independent scroll)
    style = document.createElement('style');
    style.textContent = `
      #cb-split { display:flex; gap:0; height:100%; width:100%; }
      #cb-split .cb-split-left, #cb-split .cb-split-right { display:flex; flex-direction:column; height:100%; }
      #cb-split pre { margin:0; padding:0; width:100%; height:100%; overflow:auto; background:transparent; color:inherit; }
      #cb-split .has-focus { outline: 1px dashed currentColor; outline-offset: -2px; }
      #cb-help { position:absolute; left:8px; bottom:4px; opacity:.7; font-size:.85em; pointer-events:none; }
      @media (max-width:${MOBILE_MIN_PX}px){ #cb-split { display:none; } }
    `;

    screen.innerHTML = ''; // clear single pane
    screen.appendChild(style);
    screen.appendChild(root);
    left  = root.querySelector('.cb-left-pre');
    right = root.querySelector('.cb-right-pre');

    // help line
    const help = document.createElement('div');
    help.id = 'cb-help';
    help.textContent = 'TAB: focus | j/k: move | /: filter | ENTER/p: play | r: README | h/l: resize | q: close';
    screen.appendChild(help);

    applyLayout();
    applyFocus();
    hookKeys();
  }

  function applyLayout(){
    if (!root) return;
    const rc = rowsCols();
    const colsL = mm(Math.floor(rc.cols * state.ratio), MIN_COL, rc.cols - MIN_COL);
    const colsR = rc.cols - colsL;
    root.style.gridTemplateColumns = '';
    root.children[0].style.width = `${(state.ratio*100).toFixed(1)}%`;
    root.children[1].style.width = `${((1-state.ratio)*100).toFixed(1)}%`;
    // redraw headers each refresh (left/right content renderers will call these)
    Split.redrawHeaders(colsL, colsR);
  }

  function applyFocus(){
    if (!left || !right) return;
    left.classList.toggle('has-focus', state.focus==='left');
    right.classList.toggle('has-focus', state.focus==='right');
  }

  // right pane: mixed feed + meters
  // meter backing store (ns -> {analyser, buf})
  const meters = new Map();
  let meterRAF = 0;

  function rmsFromAnalyser(an){
    const buf = new Uint8Array(an.frequencyBinCount);
    an.getByteTimeDomainData(buf);
    let sum=0;
    for (let i=0;i<buf.length;i++){ const x=(buf[i]-128)/128; sum += x*x; }
    const rms = Math.sqrt(sum / buf.length) || 0;
    const db = 20 * Math.log10(rms || 1e-6);
    return mm(db, -60, 0);
  }
  function bar(db){
    const norm = mm((db + 60)/60, 0, 1);
    const width = 24;
    const n = Math.round(norm * width);
    return `[${'#'.repeat(n)}${'.'.repeat(width-n)}] ${db.toFixed(0)}dB`;
    // use pipes style overall; bars are ascii
  }
  function pumpMeters(){
    if (!state.open) return;
    const lines = [];
    // header
    const { cols: colsR } = rowsCols();
    lines.push(headerLine('LIVE OUTPUT', colsR));
    // show latest console lines (if we’ve hooked logging)
    if (__SplitLog.length){
      const recent = __SplitLog.slice(-20);
      for (const ln of recent) lines.push(ln + '\n');
      lines.push(horizRule(colsR));
    }
    // meters
    const runs = (window.SoundEngines && SoundEngines.list && SoundEngines.list()) || [];
    for (const r of runs){
      const an = meters.get(r.ns)?.analyser || r.analyser;
      if (!an) continue;
      const db = rmsFromAnalyser(an);
      lines.push(` ${r.ns} ${r.item?.slug||''} ${bar(db)}\n`);
    }
    right.textContent = lines.join('');
    meterRAF = requestAnimationFrame(pumpMeters);
  }

  // hook into SoundEngines: when a run starts, attach analyser to its bus
  function hookEngines(){
  if (!window.SoundEngines || meters.__hooked) return;
  meters.__hooked = true;

  const _run = SoundEngines.run;
SoundEngines.run = async function patchedRun(item, opts){
  const res = await _run.call(SoundEngines, item, opts || {});
  try {
    const ns = (res && res.ns) || (opts && opts.ns) || '';
    const r = (SoundEngines.list && SoundEngines.list().find(x => x.ns === ns)) || null;
    const ctx = (window.Tone && Tone.getContext && Tone.getContext().rawContext) || window.__cbAudioCtx;
    if (r && r.bus && ctx){
      const an = ctx.createAnalyser();
      an.fftSize = 256;
      r.bus.connect(an);
      r.analyser = an;
      meters.set(ns, { analyser: an });
    }
  } catch(_){}
  return res;
};


  const _stop = SoundEngines.stop;
  SoundEngines.stop = function patchedStop(target=''){
    const out = _stop.call(SoundEngines, target);
    if (target==='all') meters.clear();
    else if (meters.has(target)) meters.delete(target);
    return out;
  };
}



  // logging hook: mirror normal console/println to right pane feed
  const __SplitLog = [];
  function hookLogging(){
    if (hookLogging.__done) return; hookLogging.__done = true;
    // Hook println if you have one
    if (window.println && !window.__cb_orig_println){
      window.__cb_orig_println = window.println;
      window.println = async (...args) => {
        __SplitLog.push(args.join(' '));
        if (__SplitLog.length > 400) __SplitLog.splice(0, __SplitLog.length - 400);
        return window.__cb_orig_println(...args);
      };
    }
    // also mirror console.log (lightly)
    const _log = console.log;
    console.log = (...a)=>{ try{ __SplitLog.push(a.join(' ')); if (__SplitLog.length>400) __SplitLog.splice(0, __SplitLog.length-400);}catch(_){} _log.apply(console,a); };
  }

  // keyboard
  function hookKeys(){
    if (hookKeys.__done) return; hookKeys.__done = true;
    window.addEventListener('keydown', (e)=>{
      if (!state.open) return;
      if (e.key === 'Tab'){ e.preventDefault(); state.focus = (state.focus==='left'?'right':'left'); applyFocus(); lsSave(); return; }
      if (e.key === 'q'){ close(); return; }
      if (e.key === 'h'){ state.ratio = mm(state.ratio - 0.05, 0.2, 0.8); applyLayout(); lsSave(); return; }
      if (e.key === 'l'){ state.ratio = mm(state.ratio + 0.05, 0.2, 0.8); applyLayout(); lsSave(); return; }
      // delegate left-pane navigation keys to Split.soundsNav if sounds mode
      if (state.mode === 'sounds'){
        if (['j','k','/','Enter','p','r'].includes(e.key) || (e.key === 'x')){
          e.preventDefault();
          Split.soundsKey(e);
        }
      }
    }, {capture:true});
  }

  function open(mode='sounds'){
    if (window.innerWidth < MOBILE_MIN_PX) { // disable on mobile
      state.open = false; return false;
    }
    lsLoad();
    state.mode = mode;
    state.open = true;
    ensureDom();
    hookLogging();
    hookEngines();
    cancelAnimationFrame(meterRAF);
    pumpMeters();
    return true;
  }
  function close(){
    state.open = false;
    cancelAnimationFrame(meterRAF);
    const screen = document.querySelector('#cb-screen');
    if (screen){ screen.innerHTML = '<pre></pre>'; } // back to single pane
  }

  // public API
  window.Split = {
    open, close,
    isOpen: ()=>state.open,
    setRatio: (r)=>{ state.ratio = mm(r, 0.2, 0.8); applyLayout(); lsSave(); },
    focus: (side)=>{ state.focus = (side==='right'?'right':'left'); applyFocus(); lsSave(); },
    swap: ()=>{ state.focus = (state.focus==='left'?'right':'left'); state.ratio = 1 - state.ratio; applyLayout(); applyFocus(); lsSave(); },
    follow: (ns)=>{ state.followNs = ns||null; },
    // called by content renderers:
    setLeft: (text)=>{ if (!left) return; left.textContent = text; },
    appendRight: (text)=>{ if (!right) return; right.textContent += text; right.scrollTop = right.scrollHeight; },
    redrawHeaders: (colsL, colsR)=>{
      if (!left || !right) return;
      // Left header drawn by sounds renderer; right header drawn in pumpMeters
    },
    // sounds-specific helpers filled by PATCH 2
    soundsRender: null,
    soundsKey: ()=>{},
  };
})();

/* -------- Run token (hard cancel) -------- */
function startRun(){
  STATE.abortFlag = false;
  STATE.turbo = false;
FastHint.end();

  STATE.runToken = {};
  return STATE.runToken;
}
function isCancelled(tok){
  return STATE.abortFlag || STATE.runToken !== tok;
}
function cancelRun(){
  STATE.abortFlag = true;
  // invalidate any in-flight awaits
  STATE.runToken = {};
}
/* -------- Tab completion (commands + slugs) -------- */
function completionsPool(){
  const names = Object.keys(COMMANDS || {});
  const slugs = DATA.works.map(w=>w.slug);
  const fromHistory = Array.from(
    new Set((STATE.history||[]).map(h => (h.split(/\s+/)[0]||'').toLowerCase()).filter(Boolean))
  );
  return Array.from(new Set([...names, ...slugs, ...fromHistory]));
}
function normalizeLinks(links){
  if(!links) return [];
  let arr = [];
  if(Array.isArray(links)){
    arr = links.map(x => (typeof x==='string' ? {label:x, url:x} : x));
  }else if(typeof links==='object'){
    arr = Object.entries(links).map(([label,url])=>({label, url}));
  }
  return arr.map((x,i)=>({
    key: String.fromCharCode(97+i), // a, b, c…
    idx: i+1,                       // 1-based
    label: x.label || `Link ${i+1}`,
    url: x.url || ''
  })).filter(x=>x.url);
}

function renderLinksList(w){
  const L = normalizeLinks(w.links);
  if(!L.length) return '(none)';
  return L.map(x => `${x.key}) ${x.label}: ${x.url}`).join('\n');
}

function resolveLinkSelector(sel, w){
  if(!w) return null;
  const L = normalizeLinks(w.links);
  if(!L.length) return null;
  if(!sel) return null;
  const s = String(sel).trim().toLowerCase();
  // letter key (a/b/…)
  let hit = L.find(x => x.key === s);
  if(hit) return hit;
  // number 1-based
  if(/^\d+$/.test(s)){
    const n = parseInt(s,10);
    if(n>=1 && n<=L.length) return L[n-1];
  }
  // label prefix/substring
  hit = L.find(x => x.label.toLowerCase().startsWith(s)) || L.find(x => x.label.toLowerCase().includes(s));
  if(hit) return hit;
  // direct URL?
  if(/^https?:\/\//.test(s)) return {url: sel, label: sel, key:'?'};
  return null;
}

function openUrlNewTab(url){
  try{
    window.open(url, '_blank', 'noopener');
  }catch(_){}
}
function cancelContactWizard({silent=false, goHome=false}={}){
  if (!silent) println('(cancelled)', {fast:true});
  STATE.contact = null;
  STATE.contactPrompt = false;
  if (goHome) return COMMANDS.home();
  promptFocus();
}

function startContactWizard(){
  STATE.contactPrompt = false;
  const email = (DATA.meta && DATA.meta.email) || 'contact@cbassuarez.com';
  STATE.contact = {
    active: true,
    step: 'name',                           // name -> email -> subject -> message -> confirm
    to: email,
    data: { name:'', from:'', subject:'', message:[] }
  };
  println('> CONTACT', {fast:true});
  println(`compose an email to ${email}`, {fast:true});
  println('name:', {fast:true});
  promptFocus();
}

function isValidEmail(s){
  // simple, forgiving check (terminal vibe; no over-validation)
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(String(s||'').trim());
}

function contactWizardPromptNext(){
  const W = STATE.contact;
  if (!W) return;
  if (W.step === 'email')   return println('email:',   {fast:true});
  if (W.step === 'subject') return println('subject:', {fast:true});
  if (W.step === 'message'){
    println('message (end with a single "." on its own line):', {fast:true});
    return;
  }
  if (W.step === 'confirm'){
    const body = W.data.message.join('\n');
    println('\n--- preview ---', {fast:true});
    println(`To: ${W.to}`, {fast:true});
    println(`From: ${W.data.name} <${W.data.from}>`, {fast:true});
    println(`Subject: ${W.data.subject}`, {fast:true});
    println('Message:\n' + body, {fast:true});
    println('---', {fast:true});
    println('send now? (y/N)', {fast:true});
  }
}
const COMMANDS_CHEATSHEET = `
# Core
help                      show this cheatsheet
home                      go to home
about [-l|--long]         about page (long prints man page)
man about                 open full manual

# Works
works | ls [-t] [-r]      list works (by year desc with -t, reverse with -r)
        [-y YEAR]         filter by year
        [-g key:value]    filter by field/tag (e.g., -g tags:album)
open <id|slug>            open a work
open link <a|1|label>     open link on current work
open <slug|id> link <…>   open link on specific work
search "term"             search in title/slug/summary/tags
tags                      list all tags

# Work context (after open)
details | credits | press | links
next | prev | back

# Blog
blog [--refresh] [-y YEAR] [-g key:value] [-r]
blog tags                  list blog tags (with counts)
read <id|slug> [--long]   open a blog post (sections-mode by default)
sections                  list headings in current post
toggle <a|1|title>        open/close a section
expand all                open all sections
collapse all              close all sections


# Media
show picture              render ASCII (about portrait or current work)
get <slug|id> picture     download that work's picture
get picture               download current (work or about portrait)

# Info
now | press | presskit | cv | contact | share

# System
theme <white|amber|green|bw>
history [--clear|-c]
clear | random | matrix

# Sprite
sprite on|off
sprite set <note|streetlight|cursor>
sprite speed <slow|medium|lively>
wave | dance | sleep | blink | flicker
`.trim();

async function contactWizardHandleInput(raw){
  const W = STATE.contact;
  if (!W) return;

  const line = String(raw||'');

  switch (W.step){
    case 'name': {
      W.data.name = line.trim();
      W.step = 'email';
      return contactWizardPromptNext();
    }
    case 'email': {
      if (!isValidEmail(line)){
        println('(please enter a valid email)', {fast:true});
        return contactWizardPromptNext();
      }
      W.data.from = line.trim();
      W.step = 'subject';
      return contactWizardPromptNext();
    }
    case 'subject': {
      W.data.subject = line.trim();
      W.step = 'message';
      return contactWizardPromptNext();
    }
    case 'message': {
      const trimmed = line.trim();
      if (trimmed === '.'){
        W.step = 'confirm';
        return contactWizardPromptNext();
      }
      W.data.message.push(line);
      // keep collecting; no new prompt line (feels like typing a here-doc)
      return;
    }
    case 'confirm': {
      const a = line.trim().toLowerCase();
      if (a === 'y' || a === 'yes' || a === 'send'){
  const payload = {
    to: W.to,                              // optional; many services ignore this
    name: W.data.name,
    email: W.data.from,                    // the sender’s email
    subject: W.data.subject,
    message: W.data.message.join('\n'),
    meta: {
      page: location.href,
      tz: Intl.DateTimeFormat().resolvedOptions().timeZone || '',
      ua: navigator.userAgent
    }
  };
  println('sending…', {fast:true});
  try{
    await sendContact(payload);
    println('sent ✓', {fast:true});
  }catch(err){
    println(`(send failed: ${err && err.message ? err.message : 'error'})`, {fast:true});
  }
} else {
  println('(not sent)', {fast:true});
}
return cancelContactWizard({silent:true});

    }
  }
}

function completeToken(tok){
  if(!tok) return '';
  const pool = completionsPool().filter(x=>x.startsWith(tok.toLowerCase()));
  if(!pool.length) return '';
  if(pool.length===1) return pool[0];
  // common prefix
  let pref = pool[0];
  for(const s of pool){ while(!s.startsWith(pref)) pref = pref.slice(0,-1); }
  return pref || pool[0];
}
function matchesFor(tok){
  if(!tok) return [];
  return completionsPool().filter(x=>x.startsWith(tok.toLowerCase()));
}
function driveIdFromLink(val){
  if(!val) return '';
  const s = String(val);
  let m = s.match(/\/d\/([a-zA-Z0-9_-]{20,})/); if(m) return m[1];
  m = s.match(/[?&]id=([a-zA-Z0-9_-]{20,})/);    if(m) return m[1];
  if(/^[a-zA-Z0-9_-]{20,}$/.test(s)) return s;
  return '';
}
function currentWork(){ return slugOrIdToWork(CURRENT.work); }

function fmtDetails(v){
  if(!v) return '(none)';
  if(Array.isArray(v)) return v.map(x=>'- '+x).join('\n');
  return String(v);
}
function fmtCredits(v){
  if(!v) return '(none)';
  if(Array.isArray(v)){
    return v.map(x=>{
      if(typeof x==='string') return x;
      const who = x.name || x.person || '';
      const role = x.role ? (x.role + (who?': ':' ')) : '';
      const url = x.url ? (' — ' + x.url) : '';
      return role + who + url;
    }).join('\n');
  }
  return String(v);
}
function fmtPress(v){
  if(!v) return '(none)';
  if(Array.isArray(v)){
    return v.map(x=>{
      if(typeof x==='string') return x;
      const q = x.quote ? `“${x.quote}” — ` : '';
      const src = [x.outlet, x.date].filter(Boolean).join(', ');
      const url = x.url ? ('\n' + x.url) : '';
      return q + src + url;
    }).join('\n\n');
  }
  return String(v);
}
function fmtLinks(v){
  if(!v) return '(none)';
  if(Array.isArray(v)){
    return v.map(x=>{
      if(typeof x==='string') return x;
      if(x.label && x.url) return `${x.label}: ${x.url}`;
      return x.url || String(x);
    }).join('\n');
  }
  if(typeof v==='object'){
    // object map of label->url
    return Object.entries(v).map(([k,u])=> `${k}: ${u}`).join('\n');
  }
  return String(v);
}

async function showSection(kind, w){
  if(!w) return println('(no work selected)');
  if(kind==='details') return section('details', fmtDetails(w.details));
  if(kind==='credits') return section('credits', fmtCredits(w.credits));
  if(kind==='press')   return section('press',   fmtPress(w.press));
  if(kind==='links')   return section('links',   renderLinksList(w));
}

// Direct, CORS-friendly download host for public files
 function driveBytesUrl(id){
   // Serves raw bytes with Access-Control-Allow-Origin: *
   return `https://drive.usercontent.google.com/uc?id=${encodeURIComponent(id)}&export=download`;
 }


    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const rnd = (min, max) => Math.floor(Math.random()*(max-min+1))+min;

    function slugOrIdToWork(key){
  const list = DATA.works;
  if(!key) return null;
  const s = String(key).trim();
  // numbers = data ids only
  if(/^\d+$/.test(s)){
    const id = parseInt(s,10);
    return list.find(w => Number(w.id) === id) || null;
  }
  const q = s.toLowerCase();
  return list.find(w =>
    (w.slug||'').toLowerCase() === q ||
    (w.title||'').toLowerCase() === q
  ) || null;
}
function slugOrIdToPost(key, posts){
  const s = String(key||'').trim();
  if(!s) return null;

  // numeric id (accepts leading zeros like '01')
  if (/^\d+$/.test(s)){
    const n = parseInt(s, 10);
    return posts.find(p => Number(p.id) === n) || null;
  }

  // slug or title (case-insensitive)
  const q = s.toLowerCase();
  return posts.find(p =>
    (p.slug||'').toLowerCase() === q ||
    (p.title||'').toLowerCase() === q
  ) || null;
}


    function formatList(list){
  const idW = Math.max(2, ...list.map(w => String(w.id||'').length));
  return list.map(w =>
    `${String(w.id).padStart(idW,'0')}  ${w.year}  ${String(w.type||'').padEnd(12)}  ${String(w.slug||'').padEnd(16)}  ${w.title||''}`
  ).join('\n');
}



    function uniqueTags(){
      const all = new Set();
      DATA.works.forEach(w => (w.tags||[]).forEach(t => all.add(t)));
      return Array.from(all).sort();
    }
    function driveImageCandidates(id){
  return [
    // Often allowed by CSP, returns straight image bytes
    `https://drive.google.com/thumbnail?id=${encodeURIComponent(id)}&sz=w1600`,
    // Direct LH3 path (works for many public files)
    `https://lh3.googleusercontent.com/d/${encodeURIComponent(id)}=w1600`,
    // Fallback raw download host
    `https://drive.usercontent.google.com/uc?id=${encodeURIComponent(id)}&export=download`
  ];
}

// --- download helpers ---
function mimeExt(t=''){
  t = t.toLowerCase();
  if(t.includes('jpeg')) return '.jpg';
  if(t.includes('jpg'))  return '.jpg';
  if(t.includes('png'))  return '.png';
  if(t.includes('gif'))  return '.gif';
  if(t.includes('webp')) return '.webp';
  return '';
}
async function terminalDownload(urls, baseName='download'){
  const tok = STATE.runToken; // cancel-aware
  let lastErr;
  for(const u of urls){
    try{
      const res = await fetch(u, {mode:'cors', credentials:'omit', cache:'no-store'});
      if(!res.ok) { lastErr = new Error(`HTTP ${res.status}`); continue; }

      const total = Number(res.headers.get('content-length')) || 0;
      const type  = res.headers.get('content-type') || '';
      const ext   = mimeExt(type) || '';
      const filename = baseName + ext;

      const label = `downloading ${filename}`;
      const el = makeProgressLine(label);

      // If no body stream (older browsers), fall back to blob-at-once
      if(!res.body || !res.body.getReader){
        const blob = await res.blob();
        saveBlob(blob, filename);
        el.classList.remove('dim');
        el.textContent = `saved ${filename} (${formatBytes(blob.size)})`;
       
        return true;
      }

      const reader = res.body.getReader();
      const chunks = [];
      let loaded = 0, t0 = performance.now(), tPrev = t0, bytesPrev = 0;

      while(true){
        if (isCancelled(tok)) { reader.cancel().catch(()=>{}); throw new Error('cancelled'); }
        const {done, value} = await reader.read();
        if(done) break;
        chunks.push(value);
        loaded += value.length;

        // speed + ETA
        const now = performance.now();
        const dt = Math.max(1, now - tPrev);
        const speed = (loaded - bytesPrev) * (1000/dt); // B/s
        const eta = total ? ((total - loaded) / Math.max(1, loaded/(now - t0)) ) : 0;

        renderProgress(el, {done:loaded, total, speed, eta, label});
        tPrev = now; bytesPrev = loaded;
      }

      const blob = new Blob(chunks, {type});
      saveBlob(blob, filename);
      el.classList.remove('dim');
      el.textContent = `saved ${filename} (${formatBytes(loaded)})`;
     
      return true;
    }catch(err){
      lastErr = err;
      // try next candidate URL
    }
  }
  throw lastErr || new Error('download failed');
}


async function downloadWorkPictureByKey(key, baseName){
    const w = slugOrIdToWork(key);
  if(!w || !w.pic) throw new Error('no picture for '+key);
  const id = driveIdFromLink(w.pic);
  if(!id) throw new Error('bad picture link');
  const urls = driveImageCandidates(id);
  await terminalDownload(urls, baseName || (w.slug||'picture'));
}

async function downloadPortraitPicture(baseName){
  const pic = DATA.meta?.portrait;
  if(!pic) throw new Error('no about picture configured');
  const id = driveIdFromLink(pic);
  if(!id) throw new Error('bad picture link');
  const urls = driveImageCandidates(id);
  await terminalDownload(urls, baseName || 'cbass-portrait');
}
function pullOutputFlag(args){
  const i = args.indexOf('-o');
  if(i>-1 && args[i+1]) return args[i+1];
  return null;
}


async function loadImageFromDriveId(id){
  const errs = [];
  for (const u of driveImageCandidates(id)){
    try { return await loadImageElement(u); }
    catch(e){ errs.push(u); }
  }
  const err = new Error('all image sources failed');
  err.sources = errs;
  throw err;
}

async function loadImageElement(url){
  // Use <img> path so CSP img-src applies (not connect-src)
   return await new Promise((resolve, reject) => {
     const img = new Image();
     img.crossOrigin = 'anonymous';       // needed to read pixels
     img.referrerPolicy = 'no-referrer';  // avoids referrer-related 403s on some hosts
img.onload = async () => {
      try { if (img.decode) await img.decode(); } catch(_) {}
      resolve(img);
    };
         img.onerror = () => reject(new Error('image load failed'));
     // add cache-buster to dodge stale 302s/CDN weirdness
     img.src = url + (url.includes('?') ? '&' : '?') + 'cb=' + Date.now();
   });
 }
function isOnAbout(){
  return location.hash === '#about' || $('#cb-path')?.textContent.endsWith('/about');
}


function fitCoverRect(srcW, srcH, dstW, dstH){
  const s = Math.max(dstW/srcW, dstH/srcH);
  const w = Math.round(srcW*s), h = Math.round(srcH*s);
  const x = Math.round((dstW - w)/2), y = Math.round((dstH - h)/2);
  return {x,y,w,h};
}
function toLuma(r,g,b){
  // Simple sRGB luma; we can add gamma later
  return 0.2126*r + 0.7152*g + 0.0722*b;
}
// sRGB → linear (per-channel)
function s2lin(u){
  u = u/255;
  return (u <= 0.04045) ? (u/12.92) : Math.pow((u+0.055)/1.055, 2.4);
}
// Linear-light luma (Rec.709)
function lumaLinear(r,g,b){
  return 0.2126*s2lin(r) + 0.7152*s2lin(g) + 0.0722*s2lin(b);
}
// Auto-levels with gentle gamma. Clips low/high tails, rescales to [0,1].
function autoLevels01(arr, lowQ=0.005, highQ=0.995, gamma=0.9){
  const n = arr.length;
  const bins = new Uint32Array(256);
  for(let i=0;i<n;i++){
    let v = Math.min(1, Math.max(0, arr[i]));
   bins[Math.min(255, Math.max(0, (v*255)|0))]++;
 }
  // CDF
  let cum = 0;
  const targetLow = n*lowQ, targetHigh = n*highQ;
  let lo=0, hi=255;
  for(let i=0;i<256;i++){ cum+=bins[i]; if(cum>=targetLow){ lo=i; break; } }
  cum = 0;
  for(let i=255;i>=0;i--){ cum+=bins[i]; if(cum>=n*(1-highQ)){ hi=i; break; } }
  const scale = (hi>lo) ? 1/((hi-lo)/255) : 1;
  for(let i=0;i<n;i++){
    let v = (arr[i]*255 - lo) * scale;
    v = Math.min(1, Math.max(0, v/255));
   // gentle gamma for midtone detail
    arr[i] = Math.pow(v, gamma);
  }
  return arr;
}
const BAYER4 = [
  [ 0,  8,  2, 10],
  [12,  4, 14,  6],
  [ 3, 11,  1,  9],
  [15,  7, 13,  5]
];
function measureAsciiCell(){
  if (measureAsciiCell._cache) return measureAsciiCell._cache;
  const pre = document.createElement('pre');
  pre.className = 'ascii-img';
  pre.style.position = 'absolute';
  pre.style.left = '-9999px';
  pre.textContent = '⣿'.repeat(100) + '\n' + '⣿'.repeat(100);
  document.body.appendChild(pre);
  const rect = pre.getBoundingClientRect();
  const ch = rect.height / 2;           // px per line
  const cw = rect.width / 100;          // px per char
  pre.remove();
  return (measureAsciiCell._cache = { cw, ch, cellAspect: cw / ch });
}

function brailleFromImage(img, cols=80, rows=40){
  const W = cols*2, H = rows*4;           // 80x40 cells ⇒ 160x160 sample grid
  const c = document.createElement('canvas'); c.width=W; c.height=H;
  const ctx = c.getContext('2d', { willReadFrequently:true });
  const sW = img.naturalWidth  || img.width  || 0;
  const sH = img.naturalHeight || img.height || 0;
  if (!sW || !sH) throw new Error('image has zero dimensions');
  const rect = fitCoverRect(sW, sH, W, H);
  // draw full source → fitted dest
  ctx.imageSmoothingEnabled = true;
  if ('imageSmoothingQuality' in ctx) ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(img, 0, 0, sW, sH, rect.x, rect.y, rect.w, rect.h);
 let data;
  try {
    data = ctx.getImageData(0,0,W,H).data;
  } catch (e) {
    throw new Error('pixel-read blocked by CORS');
  }
// 1) grayscale in linear light
  const gray = new Float32Array(W*H);
  for(let i=0, p=0; i<data.length; i+=4, p++){
    gray[p] = lumaLinear(data[i], data[i+1], data[i+2]); // 0..1
  }
  // 2) auto-levels + gentle gamma for contrast
  autoLevels01(gray, 0.005, 0.995, 0.9);
  // 3) Floyd–Steinberg dithering to 1bpp (0=ink, 1=space)
  const pix = gray; // reuse buffer
  for(let y=0; y<H; y++){
    for(let x=0; x<W; x++){
      const i = y*W + x;
      const old = pix[i];
      const newV = old < 0.5 ? 0 : 1;
      const err  = old - newV;
      pix[i] = newV;
      // distribute error
      if(x+1 < W)     pix[i+1]       = Math.min(1, Math.max(0, pix[i+1]       + err*7/16));
      if(y+1 < H){
        if(x>0)       pix[i+W-1]     = Math.min(1, Math.max(0, pix[i+W-1]     + err*3/16));
                       pix[i+W]       = Math.min(1, Math.max(0, pix[i+W]       + err*5/16));
        if(x+1 < W)   pix[i+W+1]     = Math.min(1, Math.max(0, pix[i+W+1]     + err*1/16));
      }
    }
  }
  const lines = [];  for(let ry=0; ry<rows; ry++){
    let line = '';
    for(let cx=0; cx<cols; cx++){
      let mask = 0;
      for(let dy=0; dy<4; dy++){
        for(let dx=0; dx<2; dx++){
          const px = cx*2+dx, py = ry*4+dy;
          const i = (py*W + px);
          const on = (pix[i] === 0); // 0 = ink after dithering
          if(on){
            // braille dot index mapping
            const dotIndex = (dy===0&&dx===0)?0:(dy===1&&dx===0)?1:(dy===2&&dx===0)?2:(dy===3&&dx===0)?6
                           :(dy===0&&dx===1)?3:(dy===1&&dx===1)?4:(dy===2&&dx===1)?5:7;
            mask |= (1<<dotIndex);
          }
        }
      }
      const code = 0x2800 + mask;
      line += String.fromCharCode(code);
    }
    lines.push(line);
  }
  return lines;
}

function blocksFromImage(img, cols=64, rows=32, {contrast=1.0, brightness=0.0}={}){
  const W = cols, H = rows*2; // two vertical samples per char
  const c = document.createElement('canvas'); c.width=W; c.height=H;
  const ctx = c.getContext('2d', { willReadFrequently:true });
const sW = img.naturalWidth  || img.width  || 0;
  const sH = img.naturalHeight || img.height || 0;
  if (!sW || !sH) throw new Error('image has zero dimensions');
  const rect = fitCoverRect(sW, sH, W, H);
  ctx.drawImage(img, 0, 0, sW, sH, rect.x, rect.y, rect.w, rect.h);
  let data;
 try {
   data = ctx.getImageData(0,0,W,H).data;
 } catch (e) {
   throw new Error('pixel-read blocked by CORS');
 }

  const lines = [];
  for(let y=0; y<rows; y++){
    let line = '';
    for(let x=0; x<cols; x++){
      // top pixel
      const iTop = ((y*2)*W + x)*4;
      let t = toLuma(data[iTop], data[iTop+1], data[iTop+2]) / 255;
      t = Math.min(1, Math.max(0, (t + brightness) * contrast));
      const thT = (BAYER4[(y*2)&3][x&3]+0.5)/16;
      const onTop = t < thT;

      // bottom pixel
      const iBot = ((y*2+1)*W + x)*4;
      let b = toLuma(data[iBot], data[iBot+1], data[iBot+2]) / 255;
      b = Math.min(1, Math.max(0, (b + brightness) * contrast));
      const thB = (BAYER4[(y*2+1)&3][x&3]+0.5)/16;
      const onBot = b < thB;

      // average for shade decision
      const avg = (t+b)/2;

      // 2–3 gray levels via shade glyphs
      const low = 0.66, mid = 0.45; // tuneable
      let ch;
      if (onTop && onBot) {
        // very dark → full block
        ch = (avg < mid) ? '█' : '▓';
      } else if (onTop && !onBot) {
        ch = '▀';
      } else if (!onTop && onBot) {
        ch = '▄';
      } else {
        ch = (avg < mid) ? '▒' : (avg < low ? '░' : ' ');
      }
      line += ch;
    }
    lines.push(line);
  }
  return lines;
}
async function streamAsciiToScreen(lines, {chunk=1, jitterEvery=8}={}){
  const pre = document.createElement('pre');
  pre.className = 'ascii-img';
  pre.setAttribute('role','img');
  // aria-label set by caller
  screen().appendChild(pre);

  // stick-to-bottom behavior
  const sc = screen();
  const pinned = (sc.scrollHeight - sc.scrollTop - sc.clientHeight) <= 8;

  let aborted = false;
  for(let y=0; y<lines.length; y+=chunk){
    if (STATE.abortFlag){ STATE.abortFlag=false; aborted=true; break; }
    for(let i=0;i<chunk && y+i<lines.length;i++){
      pre.textContent += lines[y+i] + (y+i<lines.length-1?'\n':'');
    }
    if (pinned) sc.scrollTop = sc.scrollHeight;
    // IO jitter every N rows
    if (y && (y % jitterEvery === 0)) await sleep(rnd(40, 120));
    await sleep(rnd(6, 14)); // scanline cadence
  }
  if (!aborted && pinned) sc.scrollTop = sc.scrollHeight;
  return pre;
}
function asciiCacheKey(fileId, cols, rows){
  return [fileId, 'braille', `${cols}x${rows}`, 'v3'].join('|');
}

async function renderAsciiFromPic(pic, ariaLabel){
  const tok = STATE.runToken;
  const fileId = driveIdFromLink(pic);
  if(!fileId) throw new Error('bad file id');

  // Load image and compute an aspect-correct grid from measured text cell
  const img = await loadImageFromDriveId(fileId);
  if (isCancelled(tok)) return;
  const { cellAspect } = measureAsciiCell();            // cw/ch for current font
  const srcW = img.naturalWidth  || img.width;
  const srcH = img.naturalHeight || img.height;
  const A = srcW / srcH;                                // image W/H
  function maxAsciiCols(){
  const scW = screen().clientWidth || window.innerWidth;
  const { cw } = measureAsciiCell();              // actual monospace char width
  return Math.max(40, Math.floor((scW - 2*16) / Math.max(1, cw))); // account for padding
}
let cols = Math.min(80, maxAsciiCols());
if (IS_MOBILE) cols = Math.min(cols, 56);         // lighter grid on phones (faster, no overflow)

  const rows = Math.max(24, Math.round((cols * cellAspect) / A)); // keep aspect

  const key = asciiCacheKey(fileId, cols, rows);
  let art = STATE.asciiCache.get(key);
  if (!art) {
    const grid = brailleFromImage(img, cols, rows);     // cover-fit inside
    art = Array.isArray(grid) ? grid.join('\n') : String(grid);
    try { localStorage.setItem('ascii:'+key, art); } catch(_) {}
    STATE.asciiCache.set(key, art);
}

  const linesArr = String(art).split('\n');
  if (isCancelled(tok)) return;
  const pre = await streamAsciiToScreen(linesArr, {chunk:1, jitterEvery:8});
  if (isCancelled(tok)) return;
  pre.setAttribute('aria-label', ariaLabel || '');
}

try {
  // lazy hydration of previous runs
  for (let i=0; i<localStorage.length; i++){
    const k = localStorage.key(i);
    if (k && k.startsWith('ascii:')) {
      STATE.asciiCache.set(k.slice(6), localStorage.getItem(k));
    }
  }
} catch(_){}
// === ASCII from arbitrary URL (uses same pipeline; Drive optional) ===
async function renderAsciiFromUrl(url, ariaLabel){
  const tok = STATE.runToken;
  let img = null;

  // If it's a Google Drive link or ID, reuse the Drive path
  const maybeId = driveIdFromLink(url);
  if (maybeId){
    img = await loadImageFromDriveId(maybeId);
  } else {
    img = await loadImageElement(url); // generic CORS-readable URL
  }
  if (isCancelled(tok)) return;

  const { cellAspect } = measureAsciiCell();
  const srcW = img.naturalWidth || img.width, srcH = img.naturalHeight || img.height;
  const A = srcW / srcH;

  function maxAsciiCols(){
    const scW = screen().clientWidth || window.innerWidth;
    const { cw } = measureAsciiCell();
    return Math.max(40, Math.floor((scW - 2*16) / Math.max(1, cw)));
  }
  let cols = Math.min(80, maxAsciiCols());
  if (IS_MOBILE) cols = Math.min(cols, 56);
  const rows = Math.max(24, Math.round((cols * cellAspect) / A));

  const grid = brailleFromImage(img, cols, rows);
  const linesArr = Array.isArray(grid) ? grid : String(grid).split('\n');
  if (isCancelled(tok)) return;
  const pre = await streamAsciiToScreen(linesArr, {chunk:1, jitterEvery:8});
  if (isCancelled(tok)) return;
  pre.setAttribute('aria-label', ariaLabel || '');
}


const FastHint = (() => {
  let timer=null, el=null, active=false;
  function start(){
    end();
    active = true;
    // only show a hint if we’re still printing after ~7s
    timer = setTimeout(() => {
      if (!active) return;
      el = document.createElement('div');
      el.className = 'line dim';
      el.textContent = '— press Enter to fast-forward —';
      screen().appendChild(el);
      screen().scrollTop = screen().scrollHeight;
    }, 7000);
  }
  function trigger(){ // user pressed Enter
    if (!active) return;
    STATE.turbo = true;
    if (el) el.textContent = '⏩ fast-forwarded';
    setTimeout(end, 250);
  }
  function end(){
    active = false;
    if (timer) clearTimeout(timer);
    timer = null;
    if (el){ el.remove(); el = null; }
  }
  return { start, trigger, end, isActive:()=>active };
})();


    /* ----------------------------
       PRINTER (typed output with simulated lag)
    ----------------------------- */
    async function print(text, {fast=false, pre=false, delay=true, nowrap=false, className=''} = {}){
  const sc = screen();
  const wasPinned = (sc.scrollHeight - sc.scrollTop - sc.clientHeight) <= 8;

  const el = document.createElement(pre ? 'pre' : 'div');
  el.className = pre ? 'line banner' : 'line';
  if (nowrap) el.classList.add('nowrap');
  if (className) el.classList.add(...String(className).split(/\s+/).filter(Boolean));
  sc.appendChild(el);
  if (wasPinned) sc.scrollTop = sc.scrollHeight;
if (!fast) FastHint.start(); 
  const chars = [...text];
  let aborted = false;
  for(let i=0;i<chars.length;i++){
    if (STATE.abortFlag){ STATE.abortFlag=false; aborted=true; break; }
    el.textContent += chars[i];
    if (wasPinned) sc.scrollTop = sc.scrollHeight;
    if(!fast && !STATE.turbo){             // NEW: no delay when turbo
      await sleep(rnd(3, 10));
    }
  }
  if(!aborted && delay) await sleep(rnd(20, 80));
  if (!aborted) FastHint.end();
  if (wasPinned) sc.scrollTop = sc.scrollHeight;
  return el;
}


    // ----- de-duped println (prevents duplicate lines) -----
const _cbRecentLines = new Map();

function _cbRecentLinesCleanup() {
  const now = performance.now();
  const cutoff = now - 1200; // keep ~1.2s of history
  for (const [k, t] of _cbRecentLines) if (t < cutoff) _cbRecentLines.delete(k);
}

async function println(line = '', opts = {}) {
  const key = String(line);
  const now = performance.now();

  // skip if the exact same line was just printed (covers double-renders)
  const last = _cbRecentLines.get(key);
  if (last && (now - last) < 400) return; // suppress near-simultaneous dup

  _cbRecentLines.set(key, now);
  if (_cbRecentLines.size > 300) _cbRecentLinesCleanup();

  return print(key + '\n', opts);
}


function clearScreen(){
  screen().innerHTML = '';
  _cbRecentLines.clear?.();
}


   /* Detect mobile/touch and enable native caret mode */
const IS_MOBILE = matchMedia('(pointer:coarse)').matches || 'ontouchstart' in window;
if (IS_MOBILE) document.documentElement.classList.add('cb-mobile');

/* Lift UI above the on-screen keyboard */
(function watchKeyboard(){
  if (!window.visualViewport) return;
  const el = rootEl();
  const update = () => {
    const vv = visualViewport;
    const kb = Math.max(0, (window.innerHeight - (vv.height + vv.offsetTop)));
    el.style.setProperty('--kb', kb + 'px');
  };
  visualViewport.addEventListener('resize', update);
  visualViewport.addEventListener('scroll', update);
  update();
})();

/* Harden input hints */
(() => {
  const inp = input();
  inp.setAttribute('autocapitalize','off');
  inp.setAttribute('inputmode','text');
  inp.setAttribute('enterkeyhint','go');
})();

function updateEcho(){
  const g = $('#cb-ghost'), h = $('#cb-hint'), c = $('#cb-caret');
  const v = input().value || '';
  g.textContent = v;                      // draw visible text

  // compute inline hint for last token
  const parts = v.split(/\s+/);
  const last = parts[parts.length-1] || '';
  let hintSuffix = '';
  if(last){
    const suggestion = completeToken(last);
    if(suggestion && suggestion.length>last.length){
      hintSuffix = suggestion.slice(last.length);
    }
  }
  h.textContent = hintSuffix;

  // position hint and caret after typed text
  const x = g.offsetWidth || 0;
  h.style.left = x + 'px';
  c.style.left = x + 'px';
}
 function promptFocus(){
      input().focus();
      // Move cursor to end
      const v = input().value; input().value=''; input().value=v;
      updateEcho();

    }


    // === Minimal Markdown-to-console renderer (headings, code, links, images) ===
async function renderMarkdownConsole(md, { mdFilePath = '', alreadyStripped = false } = {}) {
  // normalize to lines
  const lines = String(md || '').replace(/\r\n/g, '\n').split('\n');

  // collect markdown links so we can render a/b/c… list + support `open link a`
  const collected = [];
  // reset per-post link menu (so `open link …` can't see stale items)
  STATE.linkMenu = null;

  // If a post came in with inline meta still present, drop just that one line.
  if (!alreadyStripped) {
    const i = lines.findIndex(l => l.trim());
    if (i > -1 && isInlineMetaLine((lines[i] || '').trim())) {
      lines.splice(i, 1); // remove only the meta line
      while (lines.length && !lines[0].trim()) lines.shift(); // drop a single blank spacer
    }
  }

  // --- image de-dupe across quick re-renders ---
  const RECENT_MS = 1200;
  const recent = renderMarkdownConsole._recentImages || (renderMarkdownConsole._recentImages = new Map());
  {
    const now = performance.now();
    for (const [k, ts] of recent) if (now - ts > RECENT_MS) recent.delete(k);
  }

  let inCode = false;
  let codeFence = '';

  for (let idx = 0; idx < lines.length; idx++) {
    let line = lines[idx];

    // code fences
    const fence = line.match(/^```(\w+)?\s*$/);
    if (fence) {
      if (!inCode) { inCode = true; codeFence = fence[1] || ''; await println(''); }
      else          { inCode = false; codeFence = '';          await println(''); }
      continue;
    }
    if (inCode) {
      await println('  ' + line, { className: 'block' });
      continue;
    }

    // headings
    const h = line.match(/^(#{1,6})\s+(.*)$/);
    if (h) {
      const txt = h[2].trim();
      await println('');
      await println(txt.toUpperCase());
      await println('-'.repeat(Math.min(72, txt.length)));
      continue;
    }

    // horizontal rule
    if (/^\s*---\s*$/.test(line)) {
      await println('');
      await println(''.padEnd(24, '—'), { className: 'dim' });
      continue;
    }

    // images
    const img = line.match(/!\[([^\]]*)\]\(([^)]+)\)/);
    if (img) {
      const alt  = img[1] || '';
      const href = img[2].trim();
      const abs  = resolveAssetUrl(mdFilePath, href);

      // de-dupe key: post path + resolved image URL
      const key  = (mdFilePath ? mdFilePath + '|' : '') + abs;
      const now  = performance.now();
      const last = recent.get(key);

      if (!last || (now - last) > RECENT_MS) {
        recent.set(key, now);
        await println((alt ? `image: ${alt}` : 'image') + ' …', { fast: true });
        try {
          await renderAsciiFromUrl(abs, alt || 'image');
          await println('');
        } catch (e) {
          await println('(image unavailable)', { className: 'dim' });
        }
      }
      continue;
    }

    // markdown links: collect + annotate inline as [a]/[b]/…
    line = line.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (_m, label, href) => {
      const url = resolveAssetUrl(mdFilePath, href.trim());
      const key = String.fromCharCode(97 + collected.length); // a, b, c, …
      collected.push({ label, url });
      return `${label} [${key}]`;
    });

    await println(line);
  }

  // print a unified "Links" section and expose for `open link …`
  if (collected.length) {
    await println('\n> LINKS', { fast: true });
    await println(renderLinksList({ links: collected }));
    await println('\nopen link <a|1|label>', { fast: true, nowrap: true });

    // make them available to command handler(s)
    STATE.linkMenu = { items: collected, links: collected };
  }
}



    /* ----------------------------
       HELP, BANNER, THEMES
    ----------------------------- */
    async function banner(){
      await print(
`seb suarez
sonic and visual artist – console v1                                                  
`, {pre:true, fast:true, delay:false});
      await println('Type ' + wrapKbd('help') + ' to see available commands.');
          await println(`Welcome. Browse the portfolio by typing in command-line prompts. Try ${wrapKbd('works')} or ${wrapKbd('help')}.`);
    }
    async function bannerAbout(){
      await print(
`seb suarez - about    

`, {pre:true, fast:true, delay:false});
    }
    async function bannerBlog(){
      await print(
`seb suarez - blog       

`, {pre:true, fast:true, delay:false});
      await println('Words and more.');

    }
    async function bannerSounds(){
      await print(
`seb suarez - sounds  

`, {pre:true, fast:true, delay:false});
      await println('Make sounds from the command-line');

    }
    async function bannerContact(){
      await print(
`seb suarez - contact                                                 

`, {pre:true, fast:true, delay:false});
    }

    function setTheme(name){
    const el = rootEl();
    el.classList.remove('cb-theme-amber','cb-theme-green','cb-theme-white','cb-theme-bw');
    const map = {
      amber:'cb-theme-amber',
      green:'cb-theme-green',
      white:'cb-theme-white',     // existing dark background, white text
      bw:'cb-theme-bw',           // NEW light theme (black on white)
      light:'cb-theme-bw',
      paper:'cb-theme-bw',
      'black-on-white':'cb-theme-bw'
    };
    const key = (name||'').toLowerCase();
    el.classList.add(map[key] || 'cb-theme-white');
    STATE.theme = name;
    try{ LS.set(LS_KEYS.theme, name); }catch(_){}
  }
function setPathSuffix(suffix=''){
  const base = DATA.meta?.site || '/';
  pathEl().textContent = suffix ? `${base}/${suffix.replace(/^\/+/,'')}` : base;
}
    const wrapKbd = t => `\`${t}\``; // monospace inline vibe

const wrapCmd = t => `[ ${t} ]`;

function workCommandsText(){
  return 'Commands: ' + [
    'details',
    'credits',
    'get picture',
    'press',
    'links (press a/b/…)',
    'next',
    'prev',
    'back'
  ].map(wrapCmd).join(' ');
}
function blogCommandsText(mode='list'){
  const wrap = t => `[ ${t} ]`;
  const items = mode === 'post'
    ? ['blog', 'back']
    : ['read <id|slug>', 'search-blog "term"', 'blog tags', 'back'];
  return 'Commands: ' + items.map(wrap).join(' ');
}
async function printBlogCommands(mode='list'){
  await println(blogCommandsText(mode), {fast:true, nowrap:true});
}

async function printWorkCommands(){
  await println(workCommandsText(), {fast:true, nowrap:true});
}
function soundsCommandsText(){
  return 'Commands: ' + ['play <id|slug>','stop <ns|all>','back'].map(t=>`[ ${t} ]`).join(' ');
}
async function printSoundsCommands(){
  await println(soundsCommandsText(), {fast:true, nowrap:true});
}

/* ----------------------------
   SPRITE: braille-based idle buddy (note | streetlight | cursor)
----------------------------- */
const SPRITE_KEYS = {
  type:'cb.sprite.type', speed:'cb.sprite.speed', enabled:'cb.sprite.enabled'
};

const Sprite = (() => {
  const BRAILLE_IDX = (dy,dx)=> (dy===0&&dx===0)?0:(dy===1&&dx===0)?1:(dy===2&&dx===0)?2:(dy===3&&dx===0)?6
                                   :(dy===0&&dx===1)?3:(dy===1&&dx===1)?4:(dy===2&&dx===1)?5:7;

  let el, cols=28, rows=14, W=cols*2, H=rows*4;
  let kind = (LS.get(SPRITE_KEYS.type,'note')) || 'note';
  let fps = ({slow:6, medium:10, lively:14})[LS.get(SPRITE_KEYS.speed,'lively')] || 14;
  let enabled = !!LS.get(SPRITE_KEYS.enabled,true);
  let raf=0, prevTs=0, acc=0, reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  let emote = null, emoteUntil = 0;

  function ensureEl(){
    if(el) return;
    el = document.createElement('pre');
    el.id = 'cb-sprite';
    el.className = 'ascii-img';
    el.setAttribute('aria-hidden','true');
    rootEl().appendChild(el);
  }
  function allocGrid(){ return new Uint8Array(W*H); }
  function dot(grid,x,y){ if(x>=0 && y>=0 && x<W && y<H) grid[y*W+x]=1; }
  function fillRect(grid,x0,y0,x1,y1){ x0|=0; y0|=0; x1|=0; y1|=0;
    for(let y=Math.max(0,Math.min(y0,y1)); y<=Math.min(H-1,Math.max(y0,y1)); y++)
      for(let x=Math.max(0,Math.min(x0,x1)); x<=Math.min(W-1,Math.max(x0,x1)); x++)
        grid[y*W+x]=1;
  }
  function carveRect(grid,x0,y0,x1,y1){
    for(let y=Math.max(0,Math.min(y0,y1)); y<=Math.min(H-1,Math.max(y0,y1)); y++)
      for(let x=Math.max(0,Math.min(x0,x1)); x<=Math.min(W-1,Math.max(x0,x1)); x++)
        grid[y*W+x]=0;
  }
  function fillCircle(grid,cx,cy,r){
    const r2=r*r, yMin=Math.max(0,cy-r), yMax=Math.min(H-1,cy+r);
    for(let y=yMin;y<=yMax;y++){ const dy=y-cy;
      const xSpan = Math.sqrt(Math.max(0,r2 - dy*dy))|0;
      const x0=Math.max(0,cx-xSpan), x1=Math.min(W-1,cx+xSpan);
      for(let x=x0;x<=x1;x++) grid[y*W+x]=1;
    }
  }
  function carveCircle(grid,cx,cy,r){
    const r2=r*r, yMin=Math.max(0,cy-r), yMax=Math.min(H-1,cy+r);
    for(let y=yMin;y<=yMax;y++){ const dy=y-cy;
      const xSpan = Math.sqrt(Math.max(0,r2 - dy*dy))|0;
      const x0=Math.max(0,cx-xSpan), x1=Math.min(W-1,cx+xSpan);
      for(let x=x0;x<=x1;x++) grid[y*W+x]=0;
    }
  }
  function ring(grid,cx,cy,r,th=1){
    const r2=r*r, t2=(r-th)*(r-th), yMin=Math.max(0,cy-r), yMax=Math.min(H-1,cy+r);
    for(let y=yMin;y<=yMax;y++){ const dy=y-cy;
      for(let x=Math.max(0,cx-r); x<=Math.min(W-1,cx+r); x++){
        const dx=x-cx, d2=dx*dx+dy*dy;
        if(d2<=r2 && d2>=t2) grid[y*W+x]=1;
      }
    }
  }
  function toBrailleLines(grid){
    const lines = new Array(rows);
    for(let ry=0; ry<rows; ry++){
      let line='';
      for(let cx=0; cx<cols; cx++){
        let mask=0;
        for(let dy=0; dy<4; dy++){
          for(let dx=0; dx<2; dx++){
            const x = cx*2+dx, y = ry*4+dy;
            if(grid[y*W+x]) mask |= (1<<BRAILLE_IDX(dy,dx));
          }
        }
        line += String.fromCharCode(0x2800 + mask);
      }
      lines[ry]=line;
    }
    return lines;
  }

  function drawNote(grid,t){
  const sleeping = emote==='sleep';
  const amp = sleeping ? 0 : (emote==='dance' ? 10 : 6);
  const oy = Math.round((Math.sin(t*2.8)+1)*0.5*amp);
  const cx = Math.round(W*0.34), cy = Math.round(H*0.65)-oy, r = Math.round(Math.min(W,H)*0.12);
  fillCircle(grid,cx,cy,r);
  const sx0 = cx+r+2, sx1 = sx0+2, sy1=cy-r, sy0 = sy1 - Math.round(H*0.28);
  fillRect(grid,sx0,sy0,sx1,sy1);

  for(let i=0;i<6;i++){
    const y = sy0 + i*3;
    const len = sleeping ? 3 : 6 + Math.round(3*Math.sin(t*10 + i*0.7));
    fillRect(grid,sx1+1, y, sx1+1+len, y+1);
  }
  if(emote==='wave') ring(grid, cx, cy, r+5, 1);

  // sleepy bubble
  if(sleeping){
    ring(grid, cx + r + 10, cy - r - 6, 3, 1);
    fillCircle(grid, cx + r + 14, cy - r - 12, 1);
  }
}


  function drawCursor(grid,t){
    // block with eyes; quick blink; small bob on emote
    const bob = (emote==='dance') ? Math.round(3*Math.sin(t*9)) : 0;
    const rx = Math.round(W*0.68)+bob, ry = Math.round(H*0.56);
    const w = Math.round(W*0.24), h = Math.round(H*0.22);
    fillRect(grid, rx-w/2, ry-h/2, rx+w/2, ry+h/2);
    // roundness via carving corners
    carveCircle(grid, rx-w/2, ry-h/2, 3);
    carveCircle(grid, rx+w/2, ry-h/2, 3);
    carveCircle(grid, rx-w/2, ry+h/2, 3);
    carveCircle(grid, rx+w/2, ry+h/2, 3);
    const blink = (Math.sin(t*7) > 0.82) || emote==='sleep';
    const er = Math.max(1, Math.round(Math.min(w,h)*0.09));
    const ex1 = rx - Math.round(w*0.28), ex2 = rx + Math.round(w*0.28), ey = ry - Math.round(h*0.12);
    if(!blink){ carveCircle(grid, ex1, ey, er); carveCircle(grid, ex2, ey, er); }
    else { carveRect(grid, ex1-er, ey-1, ex1+er, ey+1); carveRect(grid, ex2-er, ey-1, ex2+er, ey+1); }
    if(emote==='wave') { ring(grid, rx, ry, Math.round(h*.8), 1); }
  }

  function drawStreetlight(grid,t){
  const sleeping = emote==='sleep';
  const sway = sleeping ? 0 : Math.round(2*Math.sin(t*2.7));
  const x = Math.round(W*0.78) + sway;
  const yTop = Math.round(H*0.26), headW=10, headH=6;
  fillRect(grid, x, yTop, x+1, Math.round(H*0.90));         // pole
  fillRect(grid, x-headW, yTop-2, x+2, yTop+headH);          // head

  const cx = x - Math.round(headW/2), cy = yTop + Math.round(headH/2);
  const baseR = sleeping ? 12 : 18 + Math.round(2*Math.sin(t*11));
  ring(grid,cx,cy, baseR, 2);
  ring(grid,cx,cy, Math.round(baseR*0.65), 2);

  if(!sleeping){
    const seed = (t*60)|0;
    for(let i=0;i<40;i++){
      const ang = (i*41 + seed)%360 * (Math.PI/180);
      const rr = 3 + ((i*13 + seed)%5);
      const px = cx + Math.round(Math.cos(ang)*rr);
      const py = cy + Math.round(Math.sin(ang)*rr);
      if(px>=0&&py>=0&&px<W&&py<H) grid[py*W+px] = ((seed+i)%3)?1:0;
    }
  }
  if((emote==='wave' || emote==='dance') && !sleeping){
    ring(grid,cx,cy, baseR + 6, 1);
  }
}


  function render(t){
    ensureEl();
    const grid = allocGrid();
    if(kind==='note') drawNote(grid,t);
    else if(kind==='streetlight') drawStreetlight(grid,t);
    else drawCursor(grid,t);
    el.textContent = toBrailleLines(grid).join('\n');
  }

  function loop(ts){
    if(!enabled){ prevTs=0; return; }
    if(reduced){ render(0); return; }
    if(!prevTs) prevTs = ts;
    const dt = (ts - prevTs)/1000; prevTs = ts;
    acc += dt;
    const step = 1/ fps;
    while(acc >= step){
      const t = (performance.now()/1000);
      render(t);
      acc -= step;
      if(emote && (t > emoteUntil)){ emote = null; }
    }
    raf = requestAnimationFrame(loop);
  }

  return {
    on(){
      enabled = true; LS.set(SPRITE_KEYS.enabled,true);
      ensureEl(); cancelAnimationFrame(raf); prevTs=0; acc=0; loop(performance.now());
    },
    off(){ enabled = false; LS.set(SPRITE_KEYS.enabled,false); cancelAnimationFrame(raf); if(el) el.textContent=''; },
    setType(k){
      kind = (['note','streetlight','cursor'].includes((k||'').toLowerCase())) ? k.toLowerCase() : 'note';
      LS.set(SPRITE_KEYS.type, kind);
      if(el) render(0);
    },
    setSpeed(s){
      const map = {slow:6, medium:10, lively:14};
      if(map[s]) { fps = map[s]; LS.set(SPRITE_KEYS.speed, s); }
    },
    emote(name, secs=0.8){
      emote = name; emoteUntil = (performance.now()/1000) + secs;
    },
    type(){ return kind; },
    isOn(){ return enabled; },
    render: ()=>render(0)
  };
})();
// Robust inline-meta detector (first line like: key=.. | key=..)
const _isInlineMeta = (typeof isInlineMetaLine === 'function')
  ? isInlineMetaLine
  : (s)=>/^\s*[a-z0-9_-]+\s*=.+(?:\|\s*[a-z0-9_-]+\s*=.+)+\s*$/i.test(s||'');

// Turn any string into a simple comparable token
function norm(s){ return String(s||'').toLowerCase().replace(/\s+/g,' ').trim(); }

// Select section by "a/b/…", "1/2/…", or (case-insensitive) title
function selectSectionIndex(sel, sections){
  const s = norm(sel);
  // letter a..z
  if (/^[a-z]$/.test(s)) return s.charCodeAt(0) - 97;
  // number 1..N
  if (/^\d+$/.test(s))  { const i = parseInt(s,10)-1; return (i>=0 && i<sections.length) ? i : -1; }
  // title (exact or prefix)
  for (let i=0;i<sections.length;i++){
    const t = norm(sections[i].title);
    if (t === s || t.startsWith(s)) return i;
  }
  return -1;
}

// Build the menu under the intro
async function renderSectionsMenu(){
  const ctx = STATE.blogPost;
  if (!ctx) return;
  if (!ctx.sections.length){
    await println('(no sections)');
    return;
  }
  await println('sections:');
  for (let i=0;i<ctx.sections.length;i++){
    const s = ctx.sections[i];
    const isOpen = ctx.open.has(i);
    const letter = String.fromCharCode(97 + i); // a, b, c, …
    const mark   = isOpen ? '▾' : '▸';
    await println(`  ${mark} ${letter}) ${s.title}`);
  }
  await println('');
  await println('commands: sections | expand <a|1|title>|all | collapse <a|1|title>|all | toggle <a|1|title>');
}

// Slice markdown into: { title, intro, sections[] } using H2 (##) as section heads.
// Also supports Setext headings (Title + underline of --- or ===) as *detectors*.
function sectionizePost(md, { mdFilePath='' } = {}){
  const raw = (md||'').replace(/\r\n/g,'\n');
  const lines = raw.split('\n');

  // Drop first non-empty line if it looks like inline meta
  let p = 0;
  while (p < lines.length && !lines[p].trim()) p++;
  if (p < lines.length && _isInlineMeta(lines[p])) { lines.splice(p,1); }

  // Find H1 (ATX) "# Title" or Setext "Title\n====="
  let i = 0, title = '';
  // skip leading blanks
  while (i<lines.length && !lines[i].trim()) i++;
  if (i<lines.length && /^#\s+/.test(lines[i])) {
    title = lines[i].replace(/^#\s+/,'').trim();
    i++;
  } else if (i+1<lines.length && lines[i].trim() && /^=+\s*$/.test(lines[i+1])) {
    title = lines[i].trim();
    i += 2;
  }

  // Intro: lines until first H2 (## …) or first Setext H2 (--- underline)
  const startIntro = i;
  let j = i;
  const isH2 = idx => /^##\s+/.test(lines[idx]||'');
  const isSetextH2At = idx => idx>0 && lines[idx-1].trim() && /^-+\s*$/.test(lines[idx]);
  while (j < lines.length && !isH2(j) && !isSetextH2At(j)) j++;

  const intro = lines.slice(startIntro, j).join('\n').trim();

  // Sections: iterate from j to end; start new section at each H2 or Setext H2
  const sections = [];
  let k = j;
  while (k < lines.length){
    let titleLine = '';
    let bodyStart = k+1;

    if (isH2(k)){
      titleLine = (lines[k]||'').replace(/^##\s+/, '').trim();
    } else if (isSetextH2At(k)) {
      titleLine = (lines[k-1]||'').trim();
      bodyStart = k+1;
    } else {
      // skip stray lines until next section header
      k++; continue;
    }

    // find next section boundary
    let m = bodyStart;
    while (m < lines.length && !isH2(m) && !isSetextH2At(m)) m++;

    const body = lines.slice(bodyStart, m).join('\n').trim();
    sections.push({ title: titleLine, body });

    k = m;
  }

  return { title, intro, sections, mdFilePath };
}


// Build state from a post record and render
async function renderBlogPostFromRecord(post, { openAll=false } = {}){
  // post._body or post.body should contain the markdown text; otherwise fetch.
  const md = post._body || post.body || (await fetchText(post.download_url || post.url));
  const mdFilePath = post.path || post.mdFilePath || '';

  const parts = sectionizePost(md, { mdFilePath });
  const open = new Set();
  if (openAll) for (let i=0;i<parts.sections.length;i++) open.add(i);

  STATE.blogPost = {
    slug: post.slug || post.id || post.title || 'post',
    title: parts.title || post.title || post.slug || '',
    mdFilePath,
    intro: parts.intro,
    sections: parts.sections,
    open
  };

  await renderBlogPostInteractive();
}

// Minimal resolver that prefers your existing helpers if they exist
async function lookupPostRecord(key){
  const k = String(key||'').trim().toLowerCase();

  if (typeof buildBlogIndex === 'function' && typeof slugOrIdToPost === 'function'){
    const posts = await buildBlogIndex({});
    const rec = slugOrIdToPost(k, posts);
    if (rec) return rec;
  }

  // Fallbacks if you keep posts in DATA.blog or DATA.posts
  const pools = [ (DATA && DATA.blog) || [], (DATA && DATA.posts) || [] ];
  for (const pool of pools){
    const bySlug = pool.find(p => norm(p.slug) === k || norm(p.id) === k || norm(p.title) === k);
    if (bySlug) return bySlug;
  }
  return null;
}


async function startLinkPicker(w){
  const L = normalizeLinks(w.links);
  if(!L.length) return println('(no links)');
  await section('links', L.map(x => `${x.key}) ${x.label}: ${x.url}`).join('\n'));
  await println('— press ' + L.map(x=>x.key).join('/') + ' to open; ESC to cancel —', {fast:true});
  STATE.picker = { map:Object.fromEntries(L.map(x=>[x.key, x])), workSlug:w.slug };
}



    /* ----------------------------
       COMMANDS
    ----------------------------- */
    const COMMANDS = {
      set: async function (...args){
  const printlnSafe = async (s, opts) => (typeof println === 'function' ? println(s, opts) : console.log(s));
  const usage = async () => printlnSafe(
`usage:
  set sN key value           (e.g., set s1 hRat 0.25)
  set sN key=value [k=v..]   (e.g., set s1 glitch=0.2 crush=0.15)
  set key value              (if exactly one engine is running)
  set key=value [k=v..]      (if exactly one engine is running)`);

  if (!args || !args.length) return usage();

const E = (window.SoundEngines || SoundEngines || {});
  const list = (typeof E.list === 'function') ? E.list() : [];
  const onlyOne = Array.isArray(list) && list.length === 1;

  // ns parsing
  let ns = '';
  let tokens = args.map(a => String(a));
  if (/^s\d+$/i.test(tokens[0])) ns = tokens.shift();
  else if (onlyOne) ns = list[0]?.ns || 's1';
  else if (tokens[0]?.toLowerCase() === 'all'){ ns = 'all'; tokens.shift(); }
  else { await printlnSafe('(set: specify namespace like s1, or run only one engine)'); return usage(); }
  if (!tokens.length) return usage();

  // k=v or k v → patch
  const patch = {};
  for (let i = 0; i < tokens.length; i++){
    const t = tokens[i];
    const eq = t.indexOf('=');
    if (eq > 0){ patch[t.slice(0,eq)] = coerce(t.slice(eq+1)); }
    else {
      const k = t, v = tokens[i+1];
      if (v == null || /^s\d+$/i.test(v)) { await printlnSafe(`(set: missing value for ${k})`); return usage(); }
      patch[k] = coerce(v); i++;
    }
  }

  // broadcast
  if (ns === 'all'){
    if (!Array.isArray(list) || !list.length) return printlnSafe('(set: no engines running)');
    let ok=0, fail=0;
    for (const it of list){
      (await applyUpdateOrRestart(E, it.ns, it, patch)) ? ok++ : fail++;
    }
    return printlnSafe(`set: applied to ${ok} engine(s)` + (fail? `, ${fail} failed` : ''));
  }

  // single target
  const rec = Array.isArray(list) ? list.find(e => (e?.ns||'').toLowerCase() === ns.toLowerCase()) : null;
  const success = await applyUpdateOrRestart(E, ns, rec, patch);
  if (!success){
    await printlnSafe(`(set: live update not supported by ${ns}).`);
    await printlnSafe('Tip: ensure your patch returns a controller with update(patch), and SoundEngines wires it.');
  } else {
    await printlnSafe(`ok: ${ns} ${Object.entries(patch).map(([k,v])=>`${k}=${stringify(v)}`).join(' ')}`, { fast:true });
  }

  // ----- helpers scoped to this command -----
  function coerce(v){
    const s = String(v).trim();
    if (/^(on|off)$/i.test(s)) return s.toLowerCase() === 'on';
    if (/^(true|false)$/i.test(s)) return s.toLowerCase() === 'true';
    if (/^-?\d+(\.\d+)?$/.test(s)) return Number(s);
    return s;
  }
  function stringify(v){ return (typeof v === 'string') ? JSON.stringify(v) : String(v); }

  async function applyUpdateOrRestart(Engines, nsName, recItem, patchObj){
    // 1) Try global updater APIs
    try { if (typeof Engines.update === 'function' && await Engines.update(nsName, patchObj)) return true; } catch(_){}
    try { if (typeof Engines.set    === 'function' && await Engines.set(nsName, patchObj))    return true; } catch(_){}

    // 2) Try direct controller.update
    try {
      const ctl = recItem?.controller || recItem?.ctl || null;
      if (ctl && typeof ctl.update === 'function'){
        const r = await ctl.update(patchObj);
        if (r !== false) return true;
      }
    } catch(_){}

    // 3) HOT-RESTART fallback (works even if no .update)
    try{
      // Need a record; if we didn’t have it, look it up
      let r = recItem;
      if (!r && typeof Engines.list === 'function'){
        const L = Engines.list();
        r = Array.isArray(L) ? L.find(x => (x?.ns||'').toLowerCase() === String(nsName).toLowerCase()) : null;
      }
      if (!r || !r.item || typeof Engines.run !== 'function') return false;

      const merged = Object.assign({}, r.params || {}, patchObj || {});
      await Engines.stop?.(nsName);
      await Engines.run(r.item, { ns: nsName, params: merged });
      return true;
    }catch(_){
      return false;
    }
  }
},


// REPLACE your about with this (inside const COMMANDS = { ... })
about: async function (...argv) {
  try {
    // normalize flags from variadic args
    const args = argv.map(String);
    const joined = args.join(' ').toLowerCase();
    const wantLong =
      args.includes('-l') ||
      args.includes('--long') ||
      joined.includes(' man ' ) || // future-proof if you ever pass "man" through
      joined === 'man' || joined === 'man about';

    // ensure route reflects the page (prevents "where am I?" + lets isOnAbout() work)
    if (location.hash !== '#about') {
      STATE.skipNextRouteRender = true; // avoid double-render via router
      pushRoute('#about');
    }

    // page frame
    CURRENT.work = null;
    clearScreen();
    setDocTitle('about');
    setPathSuffix('about');
    document.title = 'about — seb suarez';

    // banner: prefer bannerAbout() if present, else fall back to banner()
    if (typeof bannerAbout === 'function') {
      await bannerAbout();
    } else if (typeof banner === 'function') {
      await banner();
    }

    // ----- SHORT CARD (always prints) -----
    await println('whoami');
    await println('  cbassuarez');
    await println('  host:        Los Angeles, CA');
    await println('  roles:       composer-performer · visual artist');
    await println('  focus:       prepared-piano resonances; light as instrument');
    await println('  upcoming:    Rings/Resonators; 25HUNDRED');
    await println('  availability: commissions · installations · performances · talks');
    await println('');
    await println('Commands: [ man about ] [ show picture ] [ get picture ]  [ works -t ]  [ press ]  [ cv ]  [ contact ]  [ now ]  [ random ] ', {nowrap:true});
    await println('');
    await println('type [show picture] to render portrait, or [get picture] to download');
    await println('type [man about] for more   (or: about --long)');
    await println('');

    // OPTIONAL portrait (timeboxed so we never "hang")
    const portraitUrl = (DATA.meta && DATA.meta.portrait) || '';
    if (portraitUrl && !/drive\.google/.test(portraitUrl)) {
      try {
        await println('drawing portrait…', { fast: true });
        await Promise.race([
          renderAsciiFromPic(portraitUrl, 'portrait'),
          new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 900))
        ]);
        await println('');
      } catch {}
    }

    // ----- LONG "man page" on demand -----
    if (wantLong) {
      await println('CBASSUAREZ(1)                     USER COMMANDS                     CBASSUAREZ(1)');
      await println('');
      await println('NAME');
      await println('    cbassuarez — composer-performer + visual artist');
      await println('');
      await println('SYNOPSIS');
      await println('    works -t | press | cv | contact | now | random');
      await println('');
      await println('DESCRIPTION');
      await println('    Composer-performer focused on prepared-piano resonances and');
      await println('    spatial/industrial light as instrument. Projects span albums,');
      await println('    installation, and research. Console site; type help for cmds.');
      await println('');
      await println('LINKS');
      await println('    Press kit : ' + (DATA.meta?.presskit || '(set DATA.meta.presskit)'));
      await println('    CV        : ' + (DATA.meta?.cv || '(set DATA.meta.cv)'));
      await println('    Email     : ' + (DATA.meta?.email || ''));
      await println('');
      await println('HIGHLIGHTS');
      await println('    2023–2025  CalArts HASOM Dean’s Discretionary Fund — 3× $2,000');
      await println('    2024       Donors (Zeffy): $3,000 for 33 Strings; ~$500 in-kind');
      await println('    2024       Google Ad Grants (in-kind): $120,000/yr (Dex DSL)');
      await println('    2023       Peabody LAUNCH Grant: $5,000 (Dex DSL)');
      await println('    2023       Alba Commission Competition — Award ($300)');
      await println('    2022       Common Tone New Music Festival — Fellowship ($750)');
      await println('');
      await println('GOVERNANCE');
      await println('    2024–2025  Ethical Investment Committee, CalArts — drafted and');
      await println('               ratified ESG policy with leadership and partners.');
      await println('');
      await println('TEACHING');
      await println('    2023       CalArts AiR Week — host: Pamela Z, Attah Poku,');
      await println('               Ela Orleans, Cory Smythe, Yosvanny Terry; hosted finale.');
      await println('    2025       HASOM Project Week — guest lecture (large-format works).');
      await println('');
      await println('PROCESSES');
      const now = (DATA.meta?.now || []).slice(0,6);
      const rows = [
        ['PID','TASK','%CPU','STATE'],
        ['0001', now[0] || '—', '38.5', 'running'],
        ['0002', now[1] || '—', '21.0', 'running'],
        ['0003', now[2] || '—', '16.2', 'running'],
        ['0004', now[3] || '—', ' 9.4', 'sleeping']
      ];
      for (const r of rows) {
        await println(('    ' + r[0]).padEnd(9) + r[1].padEnd(24) + r[2].padStart(6) + '   ' + r[3]);
      }
      await println('');
      await println('TREE');
      await println('    .');
      await println('    ├── music/          albums, scores');
      await println('    ├── installations/  light, spatial works');
      await println('    ├── research/       thesis, papers');
      await println('    └── software/       SyncTimer');
      await println('');
      await println('SEE ALSO');
      await println('    Commands: [ man about ] [ show picture ] [ get picture ]  [ works -t ]  [ press ]  [ cv ]  [ contact ]  [ now ]  [ random ] ', {nowrap:true});
      await println('');
    }

    Sprite.on();
    promptFocus();
  } catch (err) {
    await println('(about failed)');
    promptFocus();
  }
},



      // --- SOUNDS: list / play / stop ---------------------------------------------
async sounds(...flags){
    clearScreen();
    setPathSuffix('sounds');
      document.title = 'sounds — seb suarez';
  await bannerSounds();
  // Keep URL-driven consistency like blog
  const h = (location.hash||'').replace(/^#/,'');
  const onSoundsHash = /^(?:ls\/sounds|sounds)(?:$|[?])/i.test(h);
  if (!onSoundsHash){
    const q = new URLSearchParams();
    const gi = flags.indexOf('-g'); if (gi > -1 && flags[gi+1]) q.set('g', flags[gi+1]);
    if (flags.includes('-r') || flags.includes('--refresh')) q.set('refresh','1');
    const qs = String(q).trim();
    pushRoute('#ls/sounds' + (qs ? ('?' + qs) : ''));
  }
  return renderSoundsList(flags);
},
async audio(flag='on'){
  const f = String(flag||'on').toLowerCase();
  if (f !== 'on' && f !== 'off'){
    await println('usage: audio on|off'); return;
  }
  if (f === 'off'){
    if (window.Tone?.getContext) { try{ await Tone.getContext().rawContext.suspend(); }catch(_){}
      await println('audio: off'); return; }
    await println('audio: off (no context)');
    return;
  }
  // on
  try{
    // piggyback the engine unlock (works even before Tone is loaded)
    if (window.SoundEngines && SoundEngines.unlock) await SoundEngines.unlock(window.Tone);
  }catch(_){} // best effort
  await println('audio: on');
},

async play(key, ...rest){
  if (!key){
    await println('usage: play <id|slug> [--ns <name>] [--engine tone|chuck] [k=v ...]');
    return;
  }
  const items = await buildSoundsIndex({});
  // after you compute `engineOverride`, change how `rec` is selected:
const k = String(key).trim().toLowerCase();
let rec = null;
if (/^\d+$/.test(k)) rec = items.find(p => Number(p.id) === parseInt(k,10));
if (!rec) {
  const candidates = items.filter(p => p.slug.toLowerCase() === k);
  if (candidates.length === 1) {
    rec = candidates[0];
  } else if (candidates.length > 1) {
    if (engineOverride) {
      rec = candidates.find(p => (p.engine||'').toLowerCase() === engineOverride) || candidates[0];
    } else {
      // default preference: tone → chuck
      rec = candidates.find(p => (p.engine||'').toLowerCase() === 'tone')
         || candidates.find(p => (p.engine||'').toLowerCase() === 'chuck')
         || candidates[0];
    }
  }
}


  // parse flags
  let ns=''; let engineOverride='';
  const params = { _: [] }; // NEW: capture positional tokens for sugar like "9 a2" 
  for (let i=0;i<rest.length;i++){
    const arg = String(rest[i]||'');
    if (arg==='--ns' && rest[i+1]) { ns = String(rest[i+1]); i++; continue; }
    if (arg==='--engine' && rest[i+1]) { engineOverride = String(rest[i+1]).toLowerCase(); i++; continue; }
    const eq = arg.indexOf('=');
    if (eq>0) { params[arg.slice(0,eq)] = arg.slice(eq+1); continue; }
    if (!arg.startsWith('--')) { params._.push(arg); } // NEW
  }
  if (engineOverride) rec = {...rec, engine:engineOverride};

  const nsUsed = ns || ('s' + (SoundEngines.list().length+1));
  await println(`running ${rec.slug} (${rec.engine}) as ${nsUsed}…`, {fast:true});
  try{
    await SoundEngines.run(rec, { ns: nsUsed, params });
    await println(`ok. type "stop ${nsUsed}" or "stop all" to stop.`);
  }catch(err){
    await println('(play failed)'); console.error(err);
  }
},

async stop(target){
  const t = String(target||'').trim() || '';
  const info = SoundEngines.stop(t || undefined);
  if (info.stopped === 'all') return println('stopped all.');
  if (info.stopped) return println(`stopped ${info.stopped}.`);
  return println('(nothing to stop)');
},

async help(){ await println(COMMANDS_CHEATSHEET); },
  // --- BLOG COMMANDS (replace any prior read/sections/expand/collapse/toggle) ---
read: async (...args) => {
  const parts = args.map(String);
  const long  = parts.includes('--long') || parts.includes('-l');
  const key   = parts.filter(p => !p.startsWith('-')).join(' ').trim();
  if (!key){ await println('usage: read <id|slug> [--long]'); return; }
  const qs = long ? '?long=1' : '';
  pushRoute(`blog/${encodeURIComponent(key)}${qs}`);
},


sections: async () => {
  if (!STATE.blogPost) return println('(no post open)');
  await renderSectionsMenu();
},

toggle: async (...args) => {
  if (!STATE.blogPost) return println('(no post open)');
  const sel = args.join(' ').trim();
  if (!sel) return println('usage: toggle <a|1|title>');
  const i = selectSectionIndex(sel, STATE.blogPost.sections);
  if (i < 0) return println('(no such section)');
  const o = STATE.blogPost.open;
  o.has(i) ? o.delete(i) : o.add(i);
  await renderBlogPostInteractive();
},

// expand <a|1|title>  |  expand all
expand: async (...args) => {
  if (!STATE.blogPost) return println('(no post open)');
  const sel = args.join(' ').trim().toLowerCase();
  if (!sel || sel === 'all' || sel === '*'){
    STATE.blogPost.sections.forEach((_s,i)=> STATE.blogPost.open.add(i));
  } else {
    const i = selectSectionIndex(sel, STATE.blogPost.sections);
    if (i < 0) return println('(no such section)');
    STATE.blogPost.open.add(i);
  }
  await renderBlogPostInteractive();
},

// collapse <a|1|title>  |  collapse all
collapse: async (...args) => {
  if (!STATE.blogPost) return println('(no post open)');
  const sel = args.join(' ').trim().toLowerCase();
  if (!sel || sel === 'all' || sel === '*'){
    STATE.blogPost.open.clear();
  } else {
    const i = selectSectionIndex(sel, STATE.blogPost.sections);
    if (i < 0) return println('(no such section)');
    STATE.blogPost.open.delete(i);
  }
  await renderBlogPostInteractive();
},




      async home(){
  CURRENT.work = null;

  // prevent the router from re-entering while we flip hashes + render
  STATE.routingGuard = true;
  try {
    // push route FIRST so the URL reflects the page we're drawing
    if (location.hash !== '#home') {
      STATE.skipNextRouteRender = true;
      location.hash = '#home';
    }

    clearScreen();
    document.title = 'home — seb suarez';
    setPathSuffix('home');
    await banner();
try { const root = rootEl(); if (root?.dataset) delete root.dataset.bannerOnly; } catch(_){}
STATE._homeBannerOnly = false; // keep if you already use it

    Sprite.on();

    // mark active route so back/other commands behave immediately
    STATE.activeRoute = 'home';
    try { LS.set(LS_KEYS.route, '#home'); } catch(_){}
  } finally {
    STATE.routingGuard = false;
  }
},

async show(sub){
  if ((sub||'').toLowerCase() !== 'picture') {
    return println('Usage: show picture');
  }
  // ABOUT (short): render portrait
  if (isOnAbout()){
    try{
      await println('drawing portrait…', {fast:true});
      await renderAsciiFromPic(DATA.meta?.portrait || '', 'portrait');
      await println('');
    }catch(err){
      await println('(portrait unavailable: ' + (err?.message||'error') + ')', {fast:true});
    }
    return;
  }
  // WORK context: (re)draw current work image if present
  const w = currentWork();
  if (w && w.pic){
    try{
      await println('drawing image…', {fast:true});
      await renderAsciiFromPic(w.pic, w.summary || w.title || '');
      await println('');
    }catch(err){
      await println('(image unavailable: ' + (err?.message||'error') + ')', {fast:true});
    }
    return;
  }
  await println('(nothing to show here)');
},


async links(slug){
    const w = slug ? slugOrIdToWork(slug) : currentWork();
    if(!w) return println('(no work selected)');
    return startLinkPicker(w);
  },

async get(...args){
  // tokens: e.g., ["ringsresonators","picture","-o","cover"]
  const tokens = args.map(x => String(x||'').trim()).filter(Boolean);
  const A = (tokens[0]||'').toLowerCase();
  const B = (tokens[1]||'').toLowerCase();
  const out = pullOutputFlag(tokens);

  // get about picture  → download portrait
  if (A === 'about' && B === 'picture'){
    try{
      await println('downloading portrait…', {fast:true});
      await downloadPortraitPicture(out);
      return println('done.', {fast:true});
    }catch(err){
      return println(`(download failed: ${err?.message||'error'})`, {fast:true});
    }
  }

  // get <slug|id> picture
  if (A && B === 'picture'){
    try{
      await println('downloading picture…', {fast:true});
      await downloadWorkPictureByKey(A, out);
      await println('done.', {fast:true});
    }catch(err){
      await println(`(download failed: ${err?.message||'error'})`, {fast:true});
    }
    if (CURRENT.work) { await println(''); await printWorkCommands(); }
    return;
  }

  // get picture  (contextual: about → portrait; work → current work)
  if (A === 'picture' && tokens.length === 1){
    if (isOnAbout()){
      try{
        await println('downloading portrait…', {fast:true});
        await downloadPortraitPicture(out);
        return println('done.', {fast:true});
      }catch(err){
        return println(`(download failed: ${err?.message||'error'})`, {fast:true});
      }
    }
    if (CURRENT.work){
      try{
        await println('downloading picture…', {fast:true});
        await downloadWorkPictureByKey(CURRENT.work, out);
        await println('done.', {fast:true});
      }catch(err){
        await println(`(download failed: ${err?.message||'error'})`, {fast:true});
      }
      await println('');
      return printWorkCommands();
    }
    return println('Usage:\n  get <slug|id> picture\n  get picture   (on about/work pages)');
  }

  return println('Usage:\n  get <slug|id> picture\n  get picture   (on about/work pages)\n  get about picture');
},
// Blog
  async blog(...flags){
    clearScreen();
    setDocTitle('blog');
    setPathSuffix('blog');

      document.title = 'blog — seb suarez';
  setPathSuffix('blog');
  await bannerBlog();
  // push route first unless we already arrived via #ls/blog or #blog
  const h = (location.hash || '').toLowerCase();
  const onBlogHash = /^#(?:ls\/blog|blog)(?:$|\?)/.test(h);
  if (!onBlogHash) {
    // (optional) turn flags into a shareable query for consistency
    const q = new URLSearchParams();
    const yi = flags.indexOf('-y'); if (yi > -1 && flags[yi+1]) q.set('y', flags[yi+1]);
    const gi = flags.indexOf('-g'); if (gi > -1 && flags[gi+1]) q.set('g', flags[gi+1]);
    if (flags.includes('-r'))        q.set('r','1');
    if (flags.includes('--refresh')) q.set('refresh','1');
    const qs = String(q).trim();
    pushRoute('#ls/blog' + (qs ? ('?' + qs) : ''));
  }

  if (flags && flags[0] && String(flags[0]).toLowerCase() === 'tags'){
    return renderBlogTags();
  }
  return renderBlogList(flags);
},



man: async function (topic) {
  const t = String(topic || '').toLowerCase();
  if (t === 'about' || t === 'cbassuarez') {
    return COMMANDS.about('--long'); // now works because about uses (...argv)
  }
  return println('(man: no entry for ' + (topic || '') + ')');
},



async now(){
  const items = DATA.meta?.now || [];
  if(!items.length) return println('(now: empty)');
  await println('now:');
  for(const it of items){ await println('  • ' + it); }
},

async cv(){
  const url = DATA.meta?.cv;
  if(url){
    await println('fetching…', {fast:true});
    await terminalDownload([url], 'cv');
  }
  else { await println('(cv: set DATA.meta.cv)'); }
},

async presskit(){
  const url = DATA.meta?.presskit;
  if(url){
    await println('fetching…', {fast:true});
    await terminalDownload([url], 'presskit');
  }
  else { await println('(presskit: set DATA.meta.presskit)'); }
},

async book(){ return COMMANDS.contact(); },

async sprite(sub, arg){
  // help
  if(!sub){
    await println(
`sprite: ${Sprite.type()} (${Sprite.isOn()?'on':'off'})
usage:
  sprite set <note|streetlight|cursor>
  sprite on | sprite off
  sprite speed <slow|medium|lively>
  wave | dance | sleep  (quick emotes)`
    );
    return;
  }
  sub = sub.toLowerCase();
  if(sub==='set' && arg){ Sprite.setType(arg); await println(`sprite set to ${Sprite.type()}`); if(location.hash==='#home') Sprite.on(); return; }
  if(sub==='on'){ Sprite.on(); return println('sprite on.'); }
  if(sub==='off'){ Sprite.off(); return println('sprite off.'); }
  if(sub==='speed' && arg){ Sprite.setSpeed(arg.toLowerCase()); return println('sprite speed set.'); }
  if(['wave','dance','sleep','blink','flicker'].includes(sub)){ Sprite.emote(sub); return; }
  await println('(unknown sprite subcommand)');
},
async wave(){ Sprite.emote('wave'); },
async dance(){ Sprite.emote('dance'); },
async sleep(){
  if(!Sprite.isOn()) Sprite.on();
  Sprite.emote('sleep', 2.5);
},

async press(){
  CURRENT.work = null;
  clearScreen();
  setDocTitle('press');
  document.title = 'press — seb suarez';
  setPathSuffix('press');
  await println(DATA.press);
  pushRoute('#press');
  showCommandsOverlay('');

},
async contact(){
  CURRENT.work = null;
  clearScreen();
      document.title = 'contact — seb suarez';
  setPathSuffix('contact');
  await bannerContact();
  await println(DATA.contact);
  await println('press Enter to open contact form / ESC to escape; type back to return home', {fast:true});
  pushRoute('#contact');
  showCommandsOverlay('');
  STATE.contactPrompt = true;
  promptFocus();
},
      async tags(){ await println('Tags:\n  ' + uniqueTags().join(', ')); },

async clear(){
  const onHome = (location.hash === '#home' || pathEl().textContent.endsWith('/home'));
  const root   = (typeof rootEl === 'function' ? rootEl() : null);

  

  // leaving Home: ensure the flag is cleared
  try { if (root && root.dataset) delete root.dataset.bannerOnly; } catch(_){}
  STATE._homeBannerOnly = false; // safe to keep if you set it elsewhere

  // normal reset for non-home pages
  if (/^#w\//i.test(location.hash)){
    const w = currentWork();
    if (w) { await renderWork(w); return; }
  }
  clearScreen();
  await banner();
  try{ Sprite.on(); }catch(_){}
  try{ promptFocus(); }catch(_){}
},




      async history(flag){
  if (flag === '-c' || flag === '--clear') {
    STATE.history = []; STATE.histIdx = 0; LS.del(LS_KEYS.history);
    return println('(history cleared)');
  }
        if(!STATE.history.length) return println('(no history)');
        const out = STATE.history.map((c,i)=> String(i+1).padStart(2,'0') + '  ' + c).join('\n');
        await println(out);
      },

      async share(){
        await println('Link: ' + location.href);
      },

      async theme(arg){
        setTheme(arg||'white');
        await println('Theme set to ' + (arg||'white') + '.');
      },


     async works(...flags){
  CURRENT.work = null;

  // prevent router re-entry while we adjust the hash + render
  STATE.routingGuard = true;
  try {
    const h = (location.hash || '').toLowerCase();
    const onWorksHash = /^#(?:ls\/works|works)(?:$|\?)/.test(h);
    if (!onWorksHash) {
      STATE.skipNextRouteRender = true;        // avoid router calling works again
      location.hash = '#ls/works';             // reflect where we are
    }

    clearScreen();
    setDocTitle?.('works');                    // keep your tab consistent
    document.title = 'works — seb suarez';
    setPathSuffix('works');

    let list = [...DATA.works];
    const parts = flags || [];

    // filter by year
    const yIdx = parts.indexOf('-y');
    if (yIdx > -1 && parts[yIdx+1]) {
      const yr = parseInt(parts[yIdx+1],10);
      list = list.filter(w => Number(w.year) === yr);
    }

    // filter by key:value
    const gIdx = parts.indexOf('-g');
    if (gIdx > -1 && parts[gIdx+1]) {
      const [k,v] = (parts[gIdx+1]+'').split(':');
      const needle = (v||'').toLowerCase();
      list = list.filter(w =>
        String(w[k]||'').toLowerCase().includes(needle) ||
        (w.tags||[]).some(t => String(t).toLowerCase().includes(needle))
      );
    }

    // sort: default by id; -t = by year desc; -r = reverse
    if (parts.includes('-t')) list.sort(byYearDesc);
    else                      list.sort(byId);
    if (parts.includes('-r')) list.reverse();

    STATE.lastList = list.map(w=>w.slug);

    const headerLines = buildWorksHeader(list);
    const rowLines    = buildWorksRows(list);

    await startPager({
      preface: headerLines,
      rows: rowLines,
      pageSize: 10,
      onDone: async () => {
        await println(`\nOpen a work with: open <id|slug>  (e.g., \`${'open 24'}\` or \`${'open constructions'}\`)`);
      }
    });

    showCommandsOverlay('');
  } finally {
    STATE.routingGuard = false;
  }
},




      // Replace your current COMMANDS.back with this:
// Replace COMMANDS.back with this minimal version:
      back: async function back(args = []){
  try{
    const raw = (location.hash || '').replace(/^#/, '');
    const isBlogList = /^(?:blog|ls\/blog)(?:$|\?)/i.test(raw);        // #blog, #ls/blog, #blog?... 
    const isBlogPost = /^blog\/[^/?#]+/i.test(raw);                     // #blog/<slug>

    // If on a post, go to list
    if (isBlogPost){
      STATE.skipNextRouteRender = true;
      location.hash = '#blog';
      return;
    }

    // If on the blog list (from *any* origin), go home
    if (isBlogList){
      STATE.skipNextRouteRender = true;
      location.hash = '#home';
      return;
    }

    // Otherwise: normal back behavior (works, about, etc.)
    if (CURRENT && CURRENT.work) CURRENT.work = null;
    window.history.back();
  } catch(e){
    console.warn('back failed', e);
  }
},




      async random(){
        const list = DATA.works;
        const item = list[Math.floor(Math.random()*list.length)];
        return COMMANDS.open(item.slug);
      },

      async open(a,b,c){
        // forms:
        // 1) open link <sel>          (context: CURRENT.work)
        // 2) open <slug|id> link <sel>
        // 3) open <slug|id>           (open work as before)
        const A = (a||'').toLowerCase();
        const B = (b||'').toLowerCase();
        if (A === 'link'){
  const w = currentWork();
  if(!w){
    const menu = STATE.linkMenu && STATE.linkMenu.items;
    if (!menu || !menu.length) {
      return println('(no work selected — try: open <slug> link <a|1|label>)');
    }
    if(!b){
      // show blog links list (same output style)
      await println(renderLinksList({ links: menu }));
      return println('Usage: open link <a|1|label>');
    }
    const pick = resolveLinkSelector(b, { links: menu });
    if(!pick) return println('(link not found)');
    await println('opening: ' + pick.url, {fast:true});
    openUrlNewTab(pick.url);
    return;
  }

  // existing Works flow:
  if(!b) { await showSection('links', w); return; }  // or your existing usage line
  // …rest unchanged
}

        if (B === 'link'){
          const w = slugOrIdToWork(a);
          if(!w) return println('Work not found.');
          if(!c) { await showSection('links', w); return println('Usage: open <slug|id> link <a|1|label>'); }
          const pick = resolveLinkSelector(c, w);
          if(!pick) return println('(link not found)');
          await println('opening: ' + pick.url, {fast:true});
          openUrlNewTab(pick.url);
          return;
        }
        // fallback: open a work
        const w = slugOrIdToWork(a);
        if(!w){ await println('Work not found.'); return; }
        await renderWork(w);
        const route = '#w/' + w.slug;
        if (location.hash !== route) {
          STATE.skipNextRouteRender = true;
          location.hash = route;
        }
      },
            async details(slug){ return showSection('details', slug ? slugOrIdToWork(slug) : currentWork()); },
      async credits(slug){ return showSection('credits', slug ? slugOrIdToWork(slug) : currentWork()); },
// rename this

async pressw(slug){ return showSection('press', slug ? slugOrIdToWork(slug) : currentWork()); },




      async search(...args){
        const qQuoted = args.join(' ');
        const q = qQuoted.replace(/^"(.*)"$/,'$1').trim().toLowerCase();
        if(!q){ return println('Usage: search "term"'); }
        const hits = DATA.works.filter(w =>
          w.title.toLowerCase().includes(q) ||
          w.slug.toLowerCase().includes(q) ||
          (w.summary||'').toLowerCase().includes(q) ||
          (w.tags||[]).some(t=>t.toLowerCase().includes(q))
        );
        if(!hits.length){ await println('No results.'); return; }
        await println(`Results for "${q}":`);
        await println(formatList(hits));
      },

      async matrix(){
        await println('Entering matrix mode. Press ESC to exit.');
        matrixOn();
      }
    };

   async function renderWork(w){
  if (!w) { await println('(work not found)'); return; }

  const tok = STATE.runToken;  // capture run token once

  // commit selection + route FIRST
  CURRENT.work = w.slug;
  const route = '#w/' + w.slug;
  if (location.hash !== route){
    STATE.skipNextRouteRender = true;
    location.hash = route;
  }

  document.title = `${w.title} — seb suarez`;
  setPathSuffix(w.slug);
  Sprite.on();
  clearScreen();

  if (STATE.asciiOn) {
    const hasDrivePic = w.pic && driveIdFromLink(w.pic);
    if (hasDrivePic) {
      await println('drawing image…', {fast:true});
      try { await renderAsciiFromPic(w.pic, w.summary || w.title || ''); }
      catch (err) { await println('(image unavailable: ' + (err?.message||'error') + ')', {fast:true}); }
      await println('');
      if (isCancelled(tok)) return;
    } else if (w.ascii) {
      await println(w.ascii, {fast:true});
      await println('');
      if (isCancelled(tok)) return;
    }
  }

  await println(`[${w.slug}]  ${w.title}  (${w.year})  <${w.type}>`);
  if (isCancelled(tok)) return;

  await println('tags: ' + (w.tags||[]).join(', '));
  await println('');
  if (isCancelled(tok)) return;

  await section('summary', w.summary || '(no summary)');
  await println('');
  if (isCancelled(tok)) return;

  await printWorkCommands();


}


// Track blog context separately so "back" doesn't cross-feed
STATE.blogLastList = null;

async function renderBlogList(flags=[]){
  CURRENT.work = null; // ensure work context is cleared
  document.title = 'blog — seb suarez';
  setPathSuffix('blog');

  const args = flags || [];
  const force = args.includes('--refresh');

  let posts = await buildBlogIndex({force});

  // filter by year
  const yIdx = args.indexOf('-y'); if (yIdx>-1 && args[yIdx+1]) {
    const yr = String(parseInt(args[yIdx+1],10));
    posts = posts.filter(p => (p.date||'').startsWith(yr+'-'));
  }
  // filter by key:value (title, type, slug)
  // filter by key:value (title, type, slug, tags)
const gIdx = args.indexOf('-g'); 
if (gIdx>-1 && args[gIdx+1]) {
  const [kRaw,vRaw] = (args[gIdx+1]+'').split(':');
  const k = (kRaw||'').toLowerCase();
  const needle = (vRaw||'').toLowerCase();

  posts = posts.filter(p => {
    if (k === 'tags') {
      const arr = Array.isArray(p.tags) ? p.tags : [];
      return arr.some(t => String(t).toLowerCase().includes(needle));
    }
    if (k === 'title')  return String(p.title||'').toLowerCase().includes(needle);
    if (k === 'slug')   return String(p.slug||'').toLowerCase().includes(needle);
    if (k === 'type')   return String(p.type||'').toLowerCase().includes(needle);
    if (k === 'date')   return String(p.date||'').toLowerCase().includes(needle);
    // default: stringify and search
    return String(p[k]||'').toLowerCase().includes(needle);
  });
}

  // sort: default date desc; -r reverses
  if (args.includes('-r')) posts = posts.slice().reverse();

  STATE.blogLastList = posts.map(p=>p.slug);

  const header = buildBlogHeader(posts);
  const rows   = buildBlogRows(posts);

// Preserve flags if we’re already on a blog-list route (URL-driven).
  // Only push when invoked from the CLI, and include the flags in the hash.
  {
    const raw = (location.hash || '').replace(/^#/, '');
    const alreadyOnList = /^(?:ls\/blog|blog)(?:$|\?)/i.test(raw);
    if (!alreadyOnList) {
      const qs = [];
      const yi = args.indexOf('-y'); if (yi > -1 && args[yi+1]) qs.push('y=' + encodeURIComponent(args[yi+1]));
      const gi = args.indexOf('-g'); if (gi > -1 && args[gi+1]) qs.push('g=' + encodeURIComponent(args[gi+1]));
      if (args.includes('-r'))          qs.push('r=1');
      if (args.includes('--refresh'))   qs.push('refresh=1');
      pushRoute('ls/blog' + (qs.length ? '?' + qs.join('&') : ''));
    }
  }  clearScreen();
  await startPager({
    preface: header,
    rows,
    pageSize: 10,
    onDone: async () => {
      await println('\nCommands: [ read <id|slug> ] [ back ]', {nowrap:true});
    }
  });
  showCommandsOverlay('');
  Sprite.on();
}

// 1) Keep the *object* version as the single renderer
function postRoute(p){ return `#blog/${p.slug || String(p.id||'')}`; }

// Split MD into sections using Setext H2 ("Title" + line of ---)
function parseSetextSections(md){
  const lines = String(md || '').replace(/\r\n/g,'\n').split('\n');
  const out = [];
  let i = 0;

  function isUnderbar(line){ return /^\s*-{3,}\s*$/.test(line); }

  while (i < lines.length){
    const title = lines[i] || '';
    const next  = lines[i+1] || '';

    if (title.trim() && isUnderbar(next)){
      // found a section; collect until next section or EOF
      i += 2;
      const body = [];
      while (i < lines.length){
        const probe = lines[i] || '';
        const after = lines[i+1] || '';
        if (probe.trim() && isUnderbar(after)) break;
        body.push(lines[i]);
        i++;
      }
      out.push({ title: title.trim(), body: body.join('\n').replace(/^\n+|\n+$/g,'') });
    } else {
      // not a section header; push into a leading "intro" bucket
      const intro = (out.length && out[0]._intro) ? out[0] : (out[0] && !out[0].title ? out[0] : null);
      if (!out.length || (out.length && out[0].title)){
        out.unshift({ title:'', body:'', _intro:true });
      }
      out[0].body += (out[0].body ? '\n' : '') + (lines[i] || '');
      i++;
    }
  }

  // remove empty intro
  if (out.length && out[0]._intro && !out[0].body.trim()){
    out.shift();
  }
  // label intro if present
  if (out.length && out[0]._intro) out[0].title = '(intro)';

  return out;
}

function sectionSelectorIndex(sel, sections){
  if (!sel) return -1;
  const s = String(sel).trim().toLowerCase();
  // a/b/c…
  if (/^[a-z]$/.test(s)){
    const i = s.charCodeAt(0) - 97;
    return (i >= 0 && i < sections.length) ? i : -1;
  }
  // 1-based
  if (/^\d+$/.test(s)){
    const n = parseInt(s,10) - 1;
    return (n >= 0 && n < sections.length) ? n : -1;
  }
  // title prefix/substring
  let i = sections.findIndex(x => (x.title||'').toLowerCase().startsWith(s));
  if (i === -1) i = sections.findIndex(x => (x.title||'').toLowerCase().includes(s));
  return i;
}

async function renderSectionsMenu(ctx){
  const rows = ctx.sections.map((sec, i) => {
    const key = String.fromCharCode(97 + i); // a/b/…
    const n   = String(i+1).padStart(2,'0');
    const mark= ctx.open.has(i) ? 'open ' : 'closed';
    const name= (sec.title || '(untitled)');
    return `${n}  ${key})  [${mark}]  ${name}`;
  });

  await println('sections');
  await println('--------');
  for (const r of rows) await println(r);
  await println('');
  await println('Commands: [ toggle <a|1|title> ]  [ expand all ]  [ collapse all ]  [ blog ]  [ back ]', {nowrap:true, fast:true});
}

// Prints: TITLE, INTRO (only), SECTIONS MENU, then OPEN sections
async function renderBlogPostInteractive(opts = {}){
  // merge any provided fields (title/slug/mdFilePath) onto saved ctx
  const ctx = Object.assign({}, STATE.blogPost || {}, opts);
  if (!ctx || !ctx.sections) return println('(no post open)');

  clearScreen();
  setDocTitle('blog');
  document.title = `${ctx.title} — seb suarez`;
  setPathSuffix(`blog/${ctx.slug}`);

  // H1 (console style) + intro
  await println(ctx.title.toUpperCase());
  await println('-'.repeat(Math.min(72, ctx.title.length)));
  if (ctx.intro && ctx.intro.trim()){
    await renderMarkdownConsole(ctx.intro, { mdFilePath: ctx.mdFilePath, alreadyStripped: true });
    await println('');
  }

  // Sections list (always shown)
  await println('> SECTIONS', {fast:true});
  for (let i=0; i<ctx.sections.length; i++){
    const s = ctx.sections[i];
    const mark = ctx.open.has(i) ? '▾' : '▸';
    const key  = String.fromCharCode(97 + i); // a/b/…
    await println(`${mark} ${key}) ${s.title}`);
  }
  await println(
    '\nCommands: [ sections ]  [ toggle <a|1|title> ]  [ expand all ]  [ collapse all ]  [ back ]',
    {fast:true, nowrap:true}
  );

  // Commands overlay (bottom-left)
  if (window.showCommandsOverlay){
    const list = ctx.sections.map((s,i)=>`  ▸ ${String.fromCharCode(97+i)}) ${s.title}`).join('\n');
    showCommandsOverlay(
`sections:
${list}

commands: sections | expand <a|1|title>|all | collapse <a|1|title>|all | toggle <a|1|title>`
    );
  }

  // Print any open sections (below the menu)
  for (let i=0;i<ctx.sections.length;i++){
    if (!ctx.open.has(i)) continue;
    const s = ctx.sections[i];
    await println('');
    await println(s.title.toUpperCase());
    await println('-'.repeat(Math.min(72, s.title.length)));
    await renderMarkdownConsole(s.body, { mdFilePath: ctx.mdFilePath, alreadyStripped: true });
  }
}



// === Replacement openBlogPost with ATX support ===
async function openBlogPost(post, flags = {}) {
  const wantLong = !!(flags.long || flags.l);
  let body = post._body || '';

  // If the first line had inline meta and wasn't stripped yet, strip it now
  const inline = parseInlineMetaFromBody(body);
  if (inline.consumedFirstLine) body = inline.body;

  // ATX-only parsing: # Title, ## Sections
  const { title: h1, intro, sections } = parseAtxSections(body);
  const finalTitle = (h1 || post.title || post.slug || '').trim() || 'Post';

  // Always set blog context so `sections`, `toggle`, etc. don’t error
  STATE.blogPost = {
    slug: post.slug,
    title: finalTitle,
    mdFilePath: post.path,
    intro: intro || '',
    sections: sections || [],
    open: new Set()
  };

  // Long mode: render full body but keep STATE.blogPost populated
  if (wantLong) {
    clearScreen();
    setDocTitle('blog');
    document.title = `${finalTitle} — blog — seb suarez`;
    setPathSuffix(`blog/${post.slug}`);
    await renderMarkdownConsole(body, { mdFilePath: post.path, alreadyStripped: true });
    return;
  }

  // Interactive mode: expand first section if present
  if (STATE.blogPost.sections.length) STATE.blogPost.open.add(0);
  await renderBlogPostInteractive();
}





// --- Commands wiring ---
COMMANDS.blog = async (...flags) => renderBlogList(flags);
COMMANDS['search-blog'] = async (q) => {
  q = (q||'').toLowerCase();
  if(!q){ await println('(usage: search-blog "term")'); return; }
  const posts = await buildBlogIndex({});
  const hits  = posts.filter(p =>
    String(p.title||'').toLowerCase().includes(q) ||
    String(p.slug||'').toLowerCase().includes(q)
  );
  if(!hits.length){ await println('(no matches)'); return; }
  await println(buildBlogHeader(hits).join('\n'));
  for(const row of buildBlogRows(hits)){ await println(row); }
  await println('\nOpen with: read <id|slug>');
};

// Make "back" route-aware (don’t cross-feed into works)
const _back = COMMANDS.back;
COMMANDS.back = async () => {
  // Blog list → Home
  if (location.hash === '#blog' || location.hash === '#ls/blog') {
    return COMMANDS.home();
  }
  // Blog post → Blog list
  if (location.hash.startsWith('#b/')) {
    return COMMANDS.blog();
  }
  // Otherwise, fall back to the original behavior
  return _back ? _back() : undefined;
};


  
    

    

async function section(name, content){
  await println('> ' + String(name || '').toUpperCase());
  await println(String(content ?? '(none)'));
}
function nextWork(slug, dir=1){
  const arr = [...DATA.works].sort(byId);
  const idx = arr.findIndex(w => w.slug === slug);
  if (idx < 0) return null;
  const ni = (idx + dir + arr.length) % arr.length;
  return arr[ni];
}

// ---- BLOG DEEP-LINKS (robust) ----
(function installBlogDeepLinks(){
  if (window._blogDL) return; window._blogDL = true;

  const CMD = (typeof COMMANDS !== 'undefined' && COMMANDS)
           || (typeof commands  !== 'undefined' && commands)
           || {};

  function qsToFlags(qs){
    const p = new URLSearchParams(qs || '');
    const out = [];

    // year (single)
    if (p.has('y')) {
      const y = (p.get('y') || '').trim();
      if (y) out.push('-y', y);
    }

    // group/filter (allow multiple g=…)
    const gs = p.getAll('g').map(s => (s || '').trim()).filter(Boolean);
    for (const g of gs) out.push('-g', g);

    // reverse: presence means true unless explicitly 0/false
    if (p.has('r')) {
      const v = (p.get('r') || '').trim().toLowerCase();
     if (v === '' || v === '1' || v === 'true') out.push('-r');
    }
    if (p.has('rev')) {
      const v = (p.get('rev') || '').trim().toLowerCase();
      if (v === '' || v === '1' || v === 'true') out.push('-r');
    }

    // refresh / nocache
    if (p.has('refresh') || (p.get('f') || '') === '1' || (p.get('nocache') || '') === '1') {
      out.push('--refresh');
    }

    return out;
  }

  function routeBlogFromHash(){
    const raw = String(location.hash || '').replace(/^#/, '');

    // #ls/blog or #blog (optional query)
    if (/^(?:ls\/blog|blog)(?:$|\?)/i.test(raw) && typeof CMD.blog === 'function'){
      const qs = raw.split('?')[1] || '';
      const flags = qsToFlags(qs);
      // prevent your main router from “double rendering” afterward
      try { STATE.skipNextRouteRender = true; } catch(_) {}
      return CMD.blog(...flags);
    }

    // #blog-tags or #blog/tags
    if (/^(?:blog-tags|blog\/tags)(?:$|\?)/i.test(raw) && typeof CMD['blog-tags'] === 'function'){
      try { STATE.skipNextRouteRender = true; } catch(_) {}
      return CMD['blog-tags']();
    }

    // #read/<slug> or #blog/<slug>
const m = raw.match(/^(?:read|blog)\/([^?]+)(?:\?(.*))?$/i);
    if (m && typeof CMD.read === 'function'){
      try { STATE.skipNextRouteRender = true; } catch(_) {}
      return CMD.read(decodeURIComponent(m[1]));
    }
  }

  // run after bootstrap so nothing wipes our render
  const boot = () => setTimeout(routeBlogFromHash, 0);

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    requestAnimationFrame(boot);
  } else {
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  }

  // handle future navigations; run on a macrotask to “win” router races
  window.addEventListener('hashchange', () => setTimeout(routeBlogFromHash, 0));
  window.addEventListener('pageshow',   () => setTimeout(routeBlogFromHash, 0)); // bfcache/safari
})();

    /* ----------------------------
       ROUTER
    ----------------------------- */
    function handleHash(){
  if (STATE.routingGuard) return;
  const h = location.hash.replace(/^#/, '');
  if (!h) return;
  
  if (h === 'ls/blog') { pushRoute('blog'); return; }

  // If command already rendered and just pushed hash, skip router re-render once
  if (STATE.skipNextRouteRender) {
    STATE.skipNextRouteRender = false;
    STATE.activeRoute = h;
    try { LS.set(LS_KEYS.route, '#'+h); } catch(_){}
    return;
  }

  if (h === STATE.activeRoute) return;
  STATE.activeRoute = h;


  if (h.startsWith('w/')) {
    const slug = h.split('/')[1];
    const w = slugOrIdToWork(slug);
    if (w) renderWork(w);
  } else {
    CURRENT.work = null;  // <— ensure we’re *not* “in a work” on non-work routes
    if (h === 'ls/works')      COMMANDS.works([]);
    else if (h === 'home')     COMMANDS.home();
    else if (h === 'about')    COMMANDS.about();
    else if (h === 'press')    COMMANDS.press();
    else if (h === 'contact')  COMMANDS.contact();
    else if (h === 'help')     COMMANDS.help();
  }
}
(function installMainRouter(){
  if (window._cbMainRouterInstalled) return;
  window._cbMainRouterInstalled = true;

  window.addEventListener('hashchange', handleHash);
  window.addEventListener('popstate', handleHash);

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', handleHash, { once: true });
  } else {
    handleHash();
  }
})();

// --- BLOG ROUTING: #ls/blog, #blog, #blog-tags, #read/<slug> ---
// --- BLOG ROUTING: #ls/blog, #blog, #blog-tags, #read/<slug> ---
(function ensureBlogRouting(){
  if (window._cbBlogRouterInstalled) return;
  window._cbBlogRouterInstalled = true;

  function qsToFlags(qs){
    const p = new URLSearchParams(qs || '');
    const out = [];
    if (p.has('y')) out.push('-y', p.get('y'));
    if (p.has('g')) out.push('-g', p.get('g'));
    // reverse: only treat blank as true if the param is PRESENT
    if (p.has('r')) {
      const v = (p.get('r') || '').toLowerCase();
      if (v === '' || v === '1' || v === 'true') out.push('-r');
    }
    if (p.has('rev')) {
      const v = (p.get('rev') || '').toLowerCase();
      if (v === '' || v === '1' || v === 'true') out.push('-r');
    }
    // refresh: keep your original semantics
    if (p.has('refresh') || p.get('f') === '1' || p.get('nocache') === '1') out.push('--refresh');
    return out;
  }

  async function onHash(){
    const raw = (location.hash || '').replace(/^#/, '');

    const isList = /^(?:ls\/blog|blog)(?:$|\?)/i.test(raw);
    const isTags = /^(?:blog-tags|blog\/tags)(?:$|\?)/i.test(raw);
    const m      = raw.match(/^(?:read|blog)\/([^?]+)$/i);
    if (!isList && !isTags && !m) return;   // not a blog route

    // honor “skip next render” just like main router
    if (STATE.skipNextRouteRender) {
      STATE.skipNextRouteRender = false;
      STATE.activeRoute = raw;
      try { LS.set(LS_KEYS.route, '#'+raw); } catch(_){}
      return;
    }

    if (STATE.routingGuard) return;
    STATE.routingGuard = true;
    try{
      STATE.activeRoute = raw;
      CURRENT.work = null;   // never “in a work” on blog routes

      if (isList){
        const qs    = raw.split('?')[1] || '';
        const flags = qsToFlags(qs);
        await renderBlogList(flags);    // direct renderer
        return;
      }

      if (isTags){
        await renderBlogTags();         // direct renderer
        return;
      }

      if (m){
  const key   = decodeURIComponent(m[1]);
  const qs    = m[2] || '';
  const flags = qsToFlags(qs);
  const posts = await buildBlogIndex({});
  const post  = slugOrIdToPost(key, posts);
  if (!post){ await println('(post not found)'); return; }
  await openBlogPost(post, flags);        // <— pass flags
  return;
}
    } finally {
      STATE.routingGuard = false;
    }
  }

  window.addEventListener('hashchange', onHash);
  window.addEventListener('popstate',  onHash);

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', onHash, { once:true });
  } else {
    onHash(); // handle direct landings / refresh
  }
})();

/* === SOUNDS ROUTING WRAPPER === */
(function(){
  let armed = false;
  function onHashSounds(){
    const raw = (location.hash || '').replace(/^#/, '');
    const m = raw.match(/^(?:ls\/sounds|sounds)(?:\?(.*))?$/i);
    if (!m) return;
    if (STATE.routingGuard) return;
    const flags = [];
    const qs = new URLSearchParams(m[1]||'');
    if (qs.get('g')) flags.push('-g', qs.get('g'));
    if (qs.get('refresh')==='1') flags.push('--refresh');
    // prevent duplicate render loop
    STATE.skipNextRouteRender = true;
    armed = true;
    COMMANDS.sounds.apply(null, flags);
    setTimeout(()=>armed=false,0);
  }
  window.addEventListener('hashchange', onHashSounds);
  // run once on boot in case hash already matches
  onHashSounds();
})();

    /* ----------------------------
       INPUT LOOP
    ----------------------------- */
    const CURRENT = { work: null, post:null, postLinks:null };

async function execCommand(raw){
  // cancel any streaming from the previous command
  cancelRun();

  // now begin the new run
  const run = startRun();

  // any new command cancels an open submenu / pager
  STATE.picker = null;
  if (STATE.pager) STATE.pager = null;

  const cmdline = (raw || '').trim();
  if (!cmdline) return;

  STATE.history.push(cmdline);
  if (STATE.history.length > 500) STATE.history = STATE.history.slice(-500);
  LS.set(LS_KEYS.history, STATE.history);
  STATE.histIdx = STATE.history.length;

  // Echo the command (preserve original casing in echo)
  await println(`/cbassuarez $ ${raw}`, {fast:true});
  if (isCancelled(run)) return;

      // Simulated lag randomly (10% chance)
      if(Math.random() < 0.10){
        await println('…loading', {fast:true});
        await sleep(rnd(150, 450));
        if (isCancelled(run)) return;
      }

      // Parse
      const tokens = cmdline.split(/\s+/);
      const cmd = tokens[0].toLowerCase();
      const args = tokens.slice(1);
// On the contact page, "back" returns home (and cancels wizard if active)
if (location.hash === '#contact' && cmd === 'back'){
  if (STATE.contact && STATE.contact.active) cancelContactWizard({silent:true});
  STATE.contactPrompt = false;
  return COMMANDS.home();
}

      // Work-local commands
      if(CURRENT.work){
        if(cmd==='details'){ await showSection('details', currentWork()); await println(''); return printWorkCommands(); }
if(cmd==='credits'){ await showSection('credits', currentWork()); await println(''); return printWorkCommands(); }
if(cmd==='press'){   await showSection('press',   currentWork()); await println(''); return printWorkCommands(); }

if(cmd==='links'){
  const w = currentWork();
  if(!w) return println('(no work selected)');
  return startLinkPicker(w);
}
        if(cmd==='next'){ const nw = nextWork(CURRENT.work, +1); return renderWork(nw); }
        if(cmd==='prev'){ const pw = nextWork(CURRENT.work, -1); return renderWork(pw); }
        if(cmd==='back'){ CURRENT.work=null; return COMMANDS.back(); }
      }

      // Global commands
      if(COMMANDS[cmd]){
        const res = await COMMANDS[cmd](...args);
        // command may have streamed output; if cancelled mid-stream, stop here
        if (isCancelled(run)) return;
        return res;
      }

      // Shorthands / aliases
      if(cmd==='ls'){ return COMMANDS.works(args); }
      if(cmd==='cd' && (!args[0] || args[0]==='/')){ return COMMANDS.home(); }
      if(cmd==='open' && args[0]){ return COMMANDS.open(args[0]); }

      flash();
      const el = await println(`Command not found: ${cmd}`);
      el.classList.add('error');
    }

    function bindInput(){
  input().addEventListener('input', updateEcho);
  input().addEventListener('focus', updateEcho);

  // SINGLE keydown handler for the input
  input().addEventListener('keydown', (e)=>{
    const key = e.key;

    if (key === 'Enter'){
      const raw = input().value || '';

      // 1) Pager first
      if (STATE.pager){
        e.preventDefault();
        const trimmed = raw.trim().toLowerCase();
        input().value = ''; updateEcho();
        if (!trimmed)     return pagerMore();   // blank → next page
        if (trimmed === 'q') return cancelPager();
        cancelPager(); // anything else → cancel pager, fall through
      }

      // 2) CONTACT: open wizard on blank Enter while on contact prompt
      if (STATE.contactPrompt && !STATE.contact){
        if (raw.trim() === ''){
          e.preventDefault();
          input().value = ''; updateEcho();
          return startContactWizard();
        }
        // else fall through to run as command
      }

      // 3) CONTACT: feed wizard lines
      if (STATE.contact && STATE.contact.active){
        e.preventDefault();
        input().value = ''; updateEcho();
        echoInstant(`/cbassuarez $ ${raw}`);
        contactWizardHandleInput(raw);
        return;
      }

      // 4) Normal command
      e.preventDefault();
      input().value = ''; updateEcho();
      return execCommand(raw);
    }

    // Tab completion
    if (key === 'Tab'){
      e.preventDefault();
      const raw = input().value;
      const parts = raw.trim().split(/\s+/);
      const last  = parts.pop() || '';
      const matches = matchesFor(last);
      if (e.shiftKey){
        if (matches.length > 1) println('matches: ' + matches.join('  '), {fast:true});
        else { flash(); }
        return;
      }
      if (matches.length){
        const pick = (matches.length===1) ? matches[0] : completeToken(last);
        if (pick){
          parts.push(pick);
          input().value = parts.join(' ');
          updateEcho();
        }
      } else { flash(); }
      return;
    }

    // History
    if (key === 'ArrowUp'){
      if (STATE.history.length){
        STATE.histIdx = Math.max(0, STATE.histIdx-1);
        input().value = STATE.history[STATE.histIdx] || '';
        updateEcho();
        e.preventDefault();
      }
      return;
    }
    if (key === 'ArrowDown'){
      if (STATE.history.length){
        STATE.histIdx = Math.min(STATE.history.length, STATE.histIdx+1);
        input().value = STATE.history[STATE.histIdx] || '';
        updateEcho();
        e.preventDefault();
      }
      return;
    }

    // Esc / Ctrl-C / Ctrl-L / j k
    if (key === 'Escape'){
      // also let Esc cancel contact wizard/prompt inline
      if (STATE.contact && STATE.contact.active){ e.preventDefault(); return cancelContactWizard(); }
      if (STATE.contactPrompt && !STATE.contact){ e.preventDefault(); return cancelContactWizard(); }
      matrixOff(); cancelRun(); return;
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c'){
      e.preventDefault(); matrixOff(); ctrlCancel(); return;
    }
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'l'){
      e.preventDefault(); COMMANDS.clear(); return;
    }
    if (!e.ctrlKey && !e.metaKey && !e.altKey && !input().value){
      if (key === 'j' && CURRENT.work){ e.preventDefault(); return renderWork(nextWork(CURRENT.work, +1)); }
      if (key === 'k' && CURRENT.work){ e.preventDefault(); return renderWork(nextWork(CURRENT.work, -1)); }
    }
  });

  // Global keys (link picker, fast-forward, Esc, Ctrl-C, etc.)
  document.addEventListener('keydown', (e)=>{
    // link picker quick-open
    if (STATE.picker){
      const key = (e.key || '').toLowerCase();
      if (key === 'escape'){
        e.preventDefault(); println('(cancelled)', {fast:true}); STATE.picker = null; return;
      }
      const pick = STATE.picker.map?.[key];
      if (pick){
        e.preventDefault(); println('opening: ' + pick.url, {fast:true}); openUrlNewTab(pick.url);
        STATE.picker = null; return;
      }
    }

    // Fast forward long prints
    if (!STATE.pager && FastHint.isActive() && e.key === 'Enter'){
      e.preventDefault(); FastHint.trigger(); return;
    }

    // Don’t interfere with outside elements
    if (!$('#cb-console').contains(e.target)) return;

    const key = (e.key || '').toLowerCase();

    // CONTACT: Esc cancels prompt or wizard globally too
    if (STATE.contact && STATE.contact.active && key==='escape'){
      e.preventDefault(); cancelContactWizard(); return;
    }
    if (STATE.contactPrompt && !STATE.contact && key==='escape'){
      e.preventDefault(); cancelContactWizard(); return;
    }

    if ((e.ctrlKey || e.metaKey) && key==='c'){ e.preventDefault(); matrixOff(); ctrlCancel(); return; }
    if (key==='escape'){ e.preventDefault(); ctrlCancel(); return; }
  }, {capture:true});

  // Mobile chips
  $('#cb-chips').addEventListener('click', (e)=>{
  const btn = e.target.closest('button[data-insert]');
  if(!btn) return;
  const cmd = btn.dataset.insert;
  input().value = cmd;
  updateEcho();

  const isTouch = window.matchMedia('(hover:none) and (pointer:coarse)').matches ||
                  window.innerWidth <= 768;
  if (isTouch){
    // run immediately on mobile
    execCommand(cmd);
  } else {
    promptFocus();
  }
});


}


    /* ----------------------------
       MATRIX MODE (easter egg)
    ----------------------------- */
    let matrixTimer=null, matrixCanvas=null, matrixCtx=null, matrixCols=[], matrixFontSize=14;

    function matrixOn(){
      if(matrixTimer) return;
      matrixCanvas = document.createElement('canvas');
      matrixCanvas.style.cssText = 'position:fixed;inset:0;z-index:1;pointer-events:none;opacity:.85;';
      $('#cb-console').appendChild(matrixCanvas);
      matrixCtx = matrixCanvas.getContext('2d');
      onResize();
      window.addEventListener('resize', onResize);
      const letters = '01';
      function step(){
        matrixCtx.fillStyle = 'rgba(0,0,0,0.08)';
        matrixCtx.fillRect(0,0,matrixCanvas.width, matrixCanvas.height);
        matrixCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cb-accent').trim() || '#0f0';
        matrixCtx.font = matrixFontSize+'px '+getComputedStyle(document.documentElement).getPropertyValue('--cb-font');
        for(let i=0;i<matrixCols.length;i++){
          const text = letters[Math.floor(Math.random()*letters.length)];
          const x = i*matrixFontSize;
          const y = matrixCols[i]*matrixFontSize;
          matrixCtx.fillText(text, x, y);
          if(y > matrixCanvas.height && Math.random() > 0.975){ matrixCols[i]=0; }
          matrixCols[i]++;
        }
      }
      matrixTimer = setInterval(step, 33);
    }
    function matrixOff(){
      if(!matrixTimer) return;
      clearInterval(matrixTimer); matrixTimer=null;
      window.removeEventListener('resize', onResize);
      if(matrixCanvas && matrixCanvas.parentNode) matrixCanvas.parentNode.removeChild(matrixCanvas);
      matrixCanvas=null; matrixCtx=null; matrixCols=[];
    }
    function onResize(){
      if(!matrixCanvas) return;
      matrixCanvas.width = window.innerWidth;
      matrixCanvas.height = window.innerHeight;
      matrixFontSize = Math.max(12, Math.min(18, Math.round(window.innerWidth/120)));
      matrixCols = Array(Math.ceil(matrixCanvas.width / matrixFontSize)).fill(0);
    }



/* Sprite FX glue: hover/focus/press, bell sync, rare flicker, typing heat.
   Requires: #cb-sprite; ideally set data-kind="note|streetlight|cursor" when switching. */
(function(){
  const el = document.getElementById('cb-sprite');
  if(!el) return;

  // helpers
  const isFine = matchMedia('(pointer:fine)').matches;
  const kind = () => (el.getAttribute('data-kind') || el.dataset.kind || 'note');

  // one extra child per sprite (allowed)
  function ensureFxLayers(){
    if(kind()==='streetlight' && !el.querySelector('.fx-cone')){
      const cone = document.createElement('i');
      cone.className = 'fx-cone';
      el.appendChild(cone);
    }
  }
  ensureFxLayers();

  // watch for sprite kind changes to attach cone when needed
  new MutationObserver(() => ensureFxLayers())
    .observe(el, { attributes:true, attributeFilter:['data-kind'] });

  // hover / active (passive on touch: only wire when pointer is fine)
  let longHoverT = null;
  if(isFine){
    el.addEventListener('mouseenter', () => {
      el.classList.add('is-hover');
      longHoverT = setTimeout(()=> el.classList.add('is-longhover'), 1200);
    });
    el.addEventListener('mouseleave', () => {
      el.classList.remove('is-hover','is-active','is-longhover');
      if(longHoverT){ clearTimeout(longHoverT); longHoverT=null; }
    });
    el.addEventListener('mousedown', () => el.classList.add('is-active'));
    window.addEventListener('mouseup', () => el.classList.remove('is-active'));
  }

  // Streetlight: rare micro-flicker, ~12–18s jitter (idles at ~0% CPU)
  let flickerT = null;
  function scheduleFlicker(){
    if(kind()!=='streetlight') { flickerT && clearTimeout(flickerT); return; }
    const jitter = 12000 + Math.random()*6000;
    flickerT = setTimeout(() => {
      el.classList.add('do-flicker');
      setTimeout(()=> el.classList.remove('do-flicker'), 180);
      scheduleFlicker();
    }, jitter);
  }
  scheduleFlicker();

  // Cursor: typing heat (debounced decay)
  let typingT = null;
  function typingHeat(){
    if(kind()!=='cursor') return;
    el.classList.add('is-typing');
    clearTimeout(typingT);
    typingT = setTimeout(()=> el.classList.remove('is-typing'), 1400);
  }
  document.addEventListener('keydown', typingHeat, {passive:true});

  // Note: pulse to sync with bell/flash
  function pulseNote(){
    if(kind()!=='note') return;
    el.classList.add('is-active','is-hover');
    setTimeout(()=> {
      el.classList.remove('is-active');
      el.classList.remove('is-hover');
    }, 280);
  }

  // Hook into your existing flash() so note bloom syncs with the bell.
  if (typeof window.flash === 'function'){
    const _flash = window.flash;
    window.flash = function(){
      try { pulseNote(); } catch(_){}
      return _flash.apply(this, arguments);
    };
  }

  // expose for debugging (optional)
  window.CB_SPRITE_FX = { pulse: pulseNote, typingHeat, ensureFxLayers };
})();
    /* ----------------------------
       INIT
    ----------------------------- */
    async function init(){
        if (window._cbInitRan) return; window._cbInitRan = true;
      bindInput();
      
      updateEcho();
      // auto-start sprite if user hasn't disabled it
try {
  const wantSprite = LS.get(SPRITE_KEYS.enabled, true);
  if (wantSprite) Sprite.on();
} catch(_) {
  // if LS read fails, just show it
  Sprite.on();
  if (matchMedia('(prefers-reduced-motion: reduce)').matches){
  if (Sprite.isOn()) Sprite.setSpeed('slow');
}

}

window.addEventListener('resize', updateEcho);
if (document.fonts && document.fonts.ready) document.fonts.ready.then(updateEcho);

// restore history
 const savedHistory = LS.get(LS_KEYS.history, []);
 if (Array.isArray(savedHistory)) {
   STATE.history = savedHistory.slice(0, 500);
   STATE.histIdx = STATE.history.length;
 }

 // restore theme (fallback to white)
 const media = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
let savedTheme = LS.get(LS_KEYS.theme, null);
const defaultTheme = (media && media.matches) ? 'white' : 'bw'; // dark→white (dark UI), light→bw
setTheme(savedTheme || defaultTheme);

// Keep following system *only if* user hasn’t chosen a theme yet
if (media && !savedTheme){
  media.addEventListener('change', e => {
    if (!LS.get(LS_KEYS.theme, null)) setTheme(e.matches ? 'white' : 'bw');
  });
}


 // --- decide initial route BEFORE rendering anything ---
const savedRoute = LS.get(LS_KEYS.route, null);
let changedHash = false;

// If there is no hash, adopt saved route or default to #home
if (!location.hash) {
  location.hash = savedRoute || '#home';
  changedHash = true; // hashchange will fire
}

// Render immediately only when a hash already exists (e.g., refresh on #w/slug)
if (!changedHash) {
  handleHash(); // shows work/list/about/etc. without flashing home first
}

// NO banner() or welcome println here anymore
document.title = 'seb suarez — sonic + visual artist (console v1)';

      promptFocus();

      // Focus screen for PgUp/PgDn scrolling
      screen().addEventListener('click', ()=> promptFocus());

      // Keyboard scrolling inside console (prevent page scroll)
      ['wheel','touchmove'].forEach(evt=>{
        document.addEventListener(evt, (e)=> {
          if(!$('#cb-console').contains(e.target)) return;
          // allow internal scroll; prevent document scroll
          if(e.cancelable) e.preventDefault();
          screen().scrollTop += (e.deltaY||0);
        }, {passive:false});
      });
    }

    document.addEventListener('DOMContentLoaded', init);
  })();
  
  </script>


</section>
